// This file is auto-generated by vercel-rpc-cli. Do not edit manually.
// Re-run `rpc generate` or use `rpc watch` to regenerate.

import { type RpcClient, RpcError, type CallOptions } from "./rpc-client";

import type { Procedures, EchoInput, EchoOutput, MathInput, MathResult, ServiceStatus, Stats, TimeResponse, TypeShowcase, UserProfile, EventKind, HealthStatus, Operation, UserRole } from "./rpc-types";

export { RpcError };
export type { RpcClient, CallOptions, Procedures, EchoInput, EchoOutput, MathInput, MathResult, ServiceStatus, Stats, TimeResponse, TypeShowcase, UserProfile, EventKind, HealthStatus, Operation, UserRole };

type QueryKey = keyof Procedures["queries"];
type QueryInput<K extends QueryKey> = Procedures["queries"][K]["input"];
type QueryOutput<K extends QueryKey> = Procedures["queries"][K]["output"];
type MutationKey = keyof Procedures["mutations"];
type MutationInput<K extends MutationKey> = Procedures["mutations"][K]["input"];
type MutationOutput<K extends MutationKey> = Procedures["mutations"][K]["output"];

type VoidQueryKey = "secret" | "status" | "time";
type NonVoidQueryKey = "hello" | "math" | "profile" | "stats" | "types";
type NonVoidMutationKey = "echo";
type MutationArgs<K extends MutationKey> = [input: MutationInput<K>];

export interface QueryOptions<K extends QueryKey> {
  /** Whether to execute the query. Reactive when passed as a getter. @default true */
  enabled?: boolean | (() => boolean);

  /** Auto-refetch interval in milliseconds. Set to 0 or omit to disable. */
  refetchInterval?: number;

  /** Initial data shown before the first fetch completes. */
  placeholderData?: QueryOutput<K>;

  /** Per-call options forwarded to client.query(). */
  callOptions?: CallOptions;

  /** Called when the query succeeds. */
  onSuccess?: (data: QueryOutput<K>) => void;

  /** Called when the query fails. */
  onError?: (error: RpcError) => void;

  /** Called when the query settles (success or failure). */
  onSettled?: () => void;
}

export interface QueryResult<K extends QueryKey> {
  /** The latest successfully resolved data, or placeholderData. */
  readonly data: QueryOutput<K> | undefined;

  /** The error from the most recent failed fetch, cleared on success. */
  readonly error: RpcError | undefined;

  /** True while a fetch is in-flight (including the initial fetch). */
  readonly isLoading: boolean;

  /** True after the first successful fetch. Stays true across refetches. */
  readonly isSuccess: boolean;

  /** True when error is set. */
  readonly isError: boolean;

  /** Manually trigger a refetch. */
  refetch: () => Promise<void>;
}

export interface MutationOptions<K extends MutationKey> {
  /** Per-call options forwarded to client.mutate(). */
  callOptions?: CallOptions;

  /** Called when the mutation succeeds. */
  onSuccess?: (data: MutationOutput<K>) => void;

  /** Called when the mutation fails. */
  onError?: (error: RpcError) => void;

  /** Called when the mutation settles (success or failure). */
  onSettled?: () => void;
}

export interface MutationResult<K extends MutationKey> {
  /** Execute the mutation. Rejects on error. */
  mutate: (...args: MutationArgs<K>) => Promise<void>;

  /** Execute the mutation and return the result. Rejects on error. */
  mutateAsync: (...args: MutationArgs<K>) => Promise<MutationOutput<K>>;

  /** The latest successfully resolved data. */
  readonly data: MutationOutput<K> | undefined;

  /** The error from the most recent failed mutation, cleared on next attempt. */
  readonly error: RpcError | undefined;

  /** True while a mutation is in-flight. */
  readonly isLoading: boolean;

  /** True after the most recent mutation succeeded. */
  readonly isSuccess: boolean;

  /** True when error is set. */
  readonly isError: boolean;

  /** Reset state back to idle (clear data, error, status). */
  reset: () => void;
}

export function createQuery<K extends "secret">(client: RpcClient, key: K, options?: QueryOptions<K>): QueryResult<K>;
export function createQuery<K extends "status">(client: RpcClient, key: K, options?: QueryOptions<K>): QueryResult<K>;
export function createQuery<K extends "time">(client: RpcClient, key: K, options?: QueryOptions<K>): QueryResult<K>;
export function createQuery<K extends "hello">(client: RpcClient, key: K, input: () => QueryInput<K>, options?: QueryOptions<K>): QueryResult<K>;
export function createQuery<K extends "math">(client: RpcClient, key: K, input: () => QueryInput<K>, options?: QueryOptions<K>): QueryResult<K>;
export function createQuery<K extends "profile">(client: RpcClient, key: K, input: () => QueryInput<K>, options?: QueryOptions<K>): QueryResult<K>;
export function createQuery<K extends "stats">(client: RpcClient, key: K, input: () => QueryInput<K>, options?: QueryOptions<K>): QueryResult<K>;
export function createQuery<K extends "types">(client: RpcClient, key: K, input: () => QueryInput<K>, options?: QueryOptions<K>): QueryResult<K>;
export function createQuery<K extends QueryKey>(
  client: RpcClient,
  ...args: unknown[]
): QueryResult<K> {
  const key = args[0] as K;

  const inputFn = typeof args[1] === "function"
    ? args[1] as () => QueryInput<K>
    : undefined;
  const options = (typeof args[1] === "object" ? args[1] : args[2]) as
    | QueryOptions<K>
    | undefined;

  let data = $state<QueryOutput<K> | undefined>(options?.placeholderData);
  let error = $state<RpcError | undefined>();
  let isLoading = $state(true);

  async function fetchData() {
    const enabled = typeof options?.enabled === "function"
      ? options.enabled()
      : (options?.enabled ?? true);
    if (!enabled) return;

    isLoading = true;
    error = undefined;
    try {
      const input = inputFn?.();
      const args: unknown[] = [key];
      if (input !== undefined) args.push(input);
      if (options?.callOptions) args.push(options.callOptions);
      data = await (client.query as Function)(...args) as QueryOutput<K>;
      options?.onSuccess?.(data!);
    } catch (e) {
      error = e as RpcError;
      options?.onError?.(error);
    } finally {
      isLoading = false;
      options?.onSettled?.();
    }
  }

  $effect(() => {
    const enabled = typeof options?.enabled === "function"
      ? options.enabled()
      : (options?.enabled ?? true);
    if (inputFn) inputFn();
    if (!enabled) return;

    void fetchData();

    if (options?.refetchInterval) {
      const interval = setInterval(fetchData, options.refetchInterval);
      return () => clearInterval(interval);
    }
  });

  return {
    get data() { return data; },
    get error() { return error; },
    get isLoading() { return isLoading; },
    get isSuccess() { return data !== undefined; },
    get isError() { return error !== undefined; },
    refetch: fetchData,
  };
}

export function createMutation<K extends MutationKey>(
  client: RpcClient,
  key: K,
  options?: MutationOptions<K>,
): MutationResult<K> {
  let data = $state<MutationOutput<K> | undefined>();
  let error = $state<RpcError | undefined>();
  let isLoading = $state(false);

  async function execute(...input: unknown[]): Promise<MutationOutput<K>> {
    isLoading = true;
    error = undefined;
    try {
      const args: unknown[] = [key];
      if (input.length > 0) args.push(input[0]);
      if (options?.callOptions) args.push(options.callOptions);
      const result = await (client.mutate as Function)(...args) as MutationOutput<K>;
      data = result;
      options?.onSuccess?.(result);
      return result;
    } catch (e) {
      error = e as RpcError;
      options?.onError?.(error);
      throw e;
    } finally {
      isLoading = false;
      options?.onSettled?.();
    }
  }

  return {
    mutate: async (...args: unknown[]) => { await execute(...args); },
    mutateAsync: (...args: unknown[]) => execute(...args),
    get data() { return data; },
    get error() { return error; },
    get isLoading() { return isLoading; },
    get isSuccess() { return data !== undefined && error === undefined; },
    get isError() { return error !== undefined; },
    reset: () => { data = undefined; error = undefined; isLoading = false; },
  } as MutationResult<K>;
}

