// This file is auto-generated by vercel-rpc-cli. Do not edit manually.
// Re-run `rpc generate` or use `rpc watch` to regenerate.

import type { Procedures, EchoInput, EchoOutput, MathInput, MathResult, ServiceStatus, Stats, TimeResponse, TypeShowcase, UserProfile, EventKind, HealthStatus, Operation, UserRole } from "./rpc-types";

export type { Procedures, EchoInput, EchoOutput, MathInput, MathResult, ServiceStatus, Stats, TimeResponse, TypeShowcase, UserProfile, EventKind, HealthStatus, Operation, UserRole };

export class RpcError extends Error {
  readonly status: number;
  readonly data: unknown;

  constructor(status: number, message: string, data?: unknown) {
    super(message);
    this.name = "RpcError";
    this.status = status;
    this.data = data;
  }
}

export interface RequestContext {
  procedure: string;
  method: "GET" | "POST";
  url: string;
  headers: Record<string, string>;
  input?: unknown;
}

export interface ResponseContext {
  procedure: string;
  method: "GET" | "POST";
  url: string;
  response: Response;
  data: unknown;
  duration: number;
}

export interface ErrorContext {
  procedure: string;
  method: "GET" | "POST";
  url: string;
  error: unknown;
}

export interface RpcClientConfig {
  baseUrl: string;
  fetch?: typeof globalThis.fetch;
  headers?:
    | Record<string, string>
    | (() => Record<string, string> | Promise<Record<string, string>>);
  onRequest?: (ctx: RequestContext) => void | Promise<void>;
  onResponse?: (ctx: ResponseContext) => void | Promise<void>;
  onError?: (ctx: ErrorContext) => void | Promise<void>;
}

async function rpcFetch(
  config: RpcClientConfig,
  method: "GET" | "POST",
  procedure: string,
  input?: unknown,
): Promise<unknown> {
  let url = `${config.baseUrl}/${procedure}`;
  const customHeaders = typeof config.headers === "function"
    ? await config.headers()
    : config.headers;
  const headers: Record<string, string> = { ...customHeaders };

  if (method === "GET" && input !== undefined) {
    url += `?input=${encodeURIComponent(JSON.stringify(input))}`;
  } else if (method === "POST" && input !== undefined) {
    headers["Content-Type"] = "application/json";
  }

  const reqCtx: RequestContext = { procedure, method, url, headers, input };
  await config.onRequest?.(reqCtx);

  const init: RequestInit = { method, headers: reqCtx.headers };
  if (method === "POST" && input !== undefined) {
    init.body = JSON.stringify(input);
  }

  const fetchFn = config.fetch ?? globalThis.fetch;
  const start = Date.now();

  let res: Response;
  try {
    res = await fetchFn(url, init);
  } catch (err) {
    await config.onError?.({ procedure, method, url, error: err });
    throw err;
  }

  if (!res.ok) {
    let data: unknown;
    try {
      data = await res.json();
    } catch {
      data = await res.text().catch(() => null);
    }
    const rpcError = new RpcError(
      res.status,
      `RPC error on "${procedure}": ${res.status} ${res.statusText}`,
      data,
    );
    await config.onError?.({ procedure, method, url, error: rpcError });
    throw rpcError;
  }

  const json = await res.json();
  const result = json?.result?.data ?? json;
  const duration = Date.now() - start;
  await config.onResponse?.({ procedure, method, url, response: res, data: result, duration });
  return result;
}

type QueryKey = keyof Procedures["queries"];
type MutationKey = keyof Procedures["mutations"];
type QueryInput<K extends QueryKey> = Procedures["queries"][K]["input"];
type QueryOutput<K extends QueryKey> = Procedures["queries"][K]["output"];
type MutationInput<K extends MutationKey> = Procedures["mutations"][K]["input"];
type MutationOutput<K extends MutationKey> = Procedures["mutations"][K]["output"];

export interface RpcClient {
  /**
   * Access a protected secret.
   * Requires a valid Bearer token in the Authorization header.
   */
  query(key: "secret"): Promise<string>;
  /** Returns current service health, uptime, and version. */
  query(key: "status"): Promise<ServiceStatus>;
  /** Returns the current server time as a Unix timestamp. */
  query(key: "time"): Promise<TimeResponse>;
  /**
   * Greet a user by name.
   * Returns a personalized greeting string.
   */
  query(key: "hello", input: string): Promise<string>;
  /** Perform a math operation. Returns an error on division by zero. */
  query(key: "math", input: MathInput): Promise<MathResult>;
  /**
   * Look up a user profile by ID.
   * 
   * Showcases serde attributes: `rename_all`, `rename`, `skip`, `default`
   * on structs and enums to demonstrate TypeScript codegen fidelity.
   */
  query(key: "profile", input: number): Promise<UserProfile>;
  /** Compute descriptive statistics for a list of numbers. */
  query(key: "stats", input: number[]): Promise<Stats>;
  /**
   * Return a type showcase demonstrating expanded type mappings.
   * 
   * Accepts a category name and returns a `TypeShowcase` struct using
   * `HashSet`, `BTreeSet`, `Box`, and `Cow` â€” all mapped to their
   * natural TypeScript equivalents.
   */
  query(key: "types", input: string): Promise<TypeShowcase>;

  /** Echo a message back, optionally transforming it to uppercase. */
  mutate(key: "echo", input: EchoInput): Promise<EchoOutput>;
}

export function createRpcClient(config: RpcClientConfig): RpcClient {
  return {
    query(key: QueryKey, ...args: unknown[]): Promise<unknown> {
      return rpcFetch(config, "GET", key, args[0]);
    },
    mutate(key: MutationKey, ...args: unknown[]): Promise<unknown> {
      return rpcFetch(config, "POST", key, args[0]);
    },
  } as RpcClient;
}
