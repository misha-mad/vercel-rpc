// This file is auto-generated by metaxy-cli. Do not edit manually.
// Re-run `metaxy generate` or use `metaxy watch` to regenerate.

import type { Procedures, BigIntDemoResponse, BigIntDemoValue, CachedTimePrivateResponse, CachedTimeResponse, CachedTimeStaleResponse, EchoInput, EchoOutput, IdempotentDemoInput, IdempotentDemoResponse, InitDemoResponse, MathInput, MathResult, ServiceStatus, Stats, TimeResponse, TimeoutDemoInput, TimeoutDemoResponse, TypeShowcase, UserProfile, EventKind, HealthStatus, Operation, UserRole } from "./rpc-types";

export type { Procedures, BigIntDemoResponse, BigIntDemoValue, CachedTimePrivateResponse, CachedTimeResponse, CachedTimeStaleResponse, EchoInput, EchoOutput, IdempotentDemoInput, IdempotentDemoResponse, InitDemoResponse, MathInput, MathResult, ServiceStatus, Stats, TimeResponse, TimeoutDemoInput, TimeoutDemoResponse, TypeShowcase, UserProfile, EventKind, HealthStatus, Operation, UserRole };

export class RpcError extends Error {
  readonly status: number;
  readonly data: unknown;

  constructor(status: number, message: string, data?: unknown) {
    super(message);
    this.name = "RpcError";
    this.status = status;
    this.data = data;
  }
}

export interface RequestContext {
  procedure: string;
  method: "GET" | "POST";
  url: string;
  headers: Record<string, string>;
  input?: unknown;
}

export interface ResponseContext {
  procedure: string;
  method: "GET" | "POST";
  url: string;
  response: Response;
  data: unknown;
  duration: number;
}

export interface ErrorContext {
  procedure: string;
  method: "GET" | "POST";
  url: string;
  error: unknown;
  attempt: number;
  willRetry: boolean;
}

export interface RetryPolicy {
  attempts: number;
  delay: number | ((attempt: number) => number);
  retryOn?: number[];
}

export interface RpcClientConfig {
  baseUrl: string;
  fetch?: typeof globalThis.fetch;
  headers?:
    | Record<string, string>
    | (() => Record<string, string> | Promise<Record<string, string>>);
  onRequest?: (ctx: RequestContext) => void | Promise<void>;
  onResponse?: (ctx: ResponseContext) => void | Promise<void>;
  onError?: (ctx: ErrorContext) => void | Promise<void>;
  retry?: RetryPolicy;
  timeout?: number;
  serialize?: (input: unknown) => string;
  deserialize?: (text: string) => unknown;
  // AbortSignal for cancelling all requests made by this client.
  signal?: AbortSignal;
  dedupe?: boolean;
}

export interface CallOptions {
  headers?: Record<string, string>;
  timeout?: number;
  signal?: AbortSignal;
  dedupe?: boolean;
}

const PROCEDURE_TIMEOUTS: Record<string, number> = {
  "timeout_demo": 3000,
};

const IDEMPOTENT_MUTATIONS: Set<string> = new Set(["idempotent_demo"]);

const DEFAULT_RETRY_ON = [408, 429, 500, 502, 503, 504];

async function rpcFetch(
  config: RpcClientConfig,
  method: "GET" | "POST",
  procedure: string,
  input?: unknown,
  callOptions?: CallOptions,
): Promise<unknown> {
  let url = `${config.baseUrl}/${procedure}`;
  const customHeaders = typeof config.headers === "function"
    ? await config.headers()
    : config.headers;
  const baseHeaders: Record<string, string> = { ...customHeaders, ...callOptions?.headers };

  if (method === "GET" && input !== undefined) {
    const serialized = config.serialize ? config.serialize(input) : JSON.stringify(input);
    url += `?input=${encodeURIComponent(serialized)}`;
  } else if (method === "POST" && input !== undefined) {
    baseHeaders["Content-Type"] = "application/json";
  }

  const fetchFn = config.fetch ?? globalThis.fetch;
  const maxAttempts = 1 + (config.retry?.attempts ?? 0);
  const retryOn = config.retry?.retryOn ?? DEFAULT_RETRY_ON;
  const effectiveTimeout = callOptions?.timeout ?? PROCEDURE_TIMEOUTS[procedure] ?? config.timeout;
  const start = Date.now();

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    const reqCtx: RequestContext = { procedure, method, url, headers: { ...baseHeaders }, input };
    await config.onRequest?.(reqCtx);

    const init: RequestInit = { method, headers: reqCtx.headers };
    if (method === "POST" && input !== undefined) {
      init.body = config.serialize ? config.serialize(input) : JSON.stringify(input);
    }

    let timeoutId: ReturnType<typeof setTimeout> | undefined;
    const signals: AbortSignal[] = [];
    if (config.signal) signals.push(config.signal);
    if (callOptions?.signal) signals.push(callOptions.signal);
    if (effectiveTimeout) {
      const controller = new AbortController();
      timeoutId = setTimeout(() => controller.abort(), effectiveTimeout);
      signals.push(controller.signal);
    }
    if (signals.length > 0) {
      init.signal = signals.length === 1 ? signals[0] : AbortSignal.any(signals);
    }

    const isRetryable = attempt < maxAttempts && (method === "GET" || IDEMPOTENT_MUTATIONS.has(procedure));

    try {
      const res = await fetchFn(url, init);

      if (!res.ok) {
        let data: unknown;
        try {
          data = await res.json();
        } catch {
          data = await res.text().catch(() => null);
        }
        const rpcError = new RpcError(
          res.status,
          `RPC error on "${procedure}": ${res.status} ${res.statusText}`,
          data,
        );
        const canRetry = retryOn.includes(res.status) && isRetryable;
        await config.onError?.({ procedure, method, url, error: rpcError, attempt, willRetry: canRetry });
        if (!canRetry) throw rpcError;
      } else {
        const json = config.deserialize ? config.deserialize(await res.text()) : await res.json();
        const result = json?.result?.data ?? json;
        const duration = Date.now() - start;
        await config.onResponse?.({ procedure, method, url, response: res, data: result, duration });
        return result;
      }
    } catch (err) {
      if (err instanceof RpcError) throw err;
      await config.onError?.({ procedure, method, url, error: err, attempt, willRetry: isRetryable });
      if (!isRetryable) throw err;
    } finally {
      if (timeoutId !== undefined) clearTimeout(timeoutId);
    }

    if (config.retry) {
      const d = typeof config.retry.delay === "function"
        ? config.retry.delay(attempt) : config.retry.delay;
      await new Promise(r => setTimeout(r, d));
    }
  }
}

function dedupKey(procedure: string, input: unknown, config: RpcClientConfig): string {
  const serialized = input === undefined
    ? ""
    : config.serialize
      ? config.serialize(input)
      : JSON.stringify(input);
  return procedure + ":" + serialized;
}

function wrapWithSignal<T>(promise: Promise<T>, signal?: AbortSignal): Promise<T> {
  if (!signal) return promise;
  if (signal.aborted) return Promise.reject(signal.reason);
  return new Promise<T>((resolve, reject) => {
    const onAbort = () => reject(signal.reason);
    signal.addEventListener("abort", onAbort, { once: true });
    promise.then(
      (value) => { signal.removeEventListener("abort", onAbort); resolve(value); },
      (error) => { signal.removeEventListener("abort", onAbort); reject(error); },
    );
  });
}

type QueryKey = keyof Procedures["queries"];
type MutationKey = keyof Procedures["mutations"];
type QueryInput<K extends QueryKey> = Procedures["queries"][K]["input"];
type QueryOutput<K extends QueryKey> = Procedures["queries"][K]["output"];
type MutationInput<K extends MutationKey> = Procedures["mutations"][K]["input"];
type MutationOutput<K extends MutationKey> = Procedures["mutations"][K]["output"];

const VOID_QUERIES: Set<string> = new Set(["bigint_demo", "cached_time", "cached_time_private", "cached_time_stale", "secret", "status", "time", "types"]);

export interface RpcClient {
  /** Return a set of u64 values at precision boundaries. */
  query(key: "bigint_demo"): Promise<BigIntDemoResponse>;
  query(key: "bigint_demo", options: CallOptions): Promise<BigIntDemoResponse>;
  /** Returns server time, cached on CDN for 30 seconds. */
  query(key: "cached_time"): Promise<CachedTimeResponse>;
  query(key: "cached_time", options: CallOptions): Promise<CachedTimeResponse>;
  /** Returns server time, cached in browser only for 1 minute (no CDN). */
  query(key: "cached_time_private"): Promise<CachedTimePrivateResponse>;
  query(key: "cached_time_private", options: CallOptions): Promise<CachedTimePrivateResponse>;
  /** Returns server time, cached 10s + stale for 30s while revalidating. */
  query(key: "cached_time_stale"): Promise<CachedTimeStaleResponse>;
  query(key: "cached_time_stale", options: CallOptions): Promise<CachedTimeStaleResponse>;
  /**
   * Access a protected secret.
   * Requires a valid Bearer token in the Authorization header.
   */
  query(key: "secret"): Promise<string>;
  query(key: "secret", options: CallOptions): Promise<string>;
  /** Returns current service health, uptime, and version. */
  query(key: "status"): Promise<ServiceStatus>;
  query(key: "status", options: CallOptions): Promise<ServiceStatus>;
  /** Returns the current server time as a Unix timestamp. */
  query(key: "time"): Promise<TimeResponse>;
  query(key: "time", options: CallOptions): Promise<TimeResponse>;
  /** Return a showcase of every supported type mapping. */
  query(key: "types"): Promise<TypeShowcase>;
  query(key: "types", options: CallOptions): Promise<TypeShowcase>;
  /**
   * Greet a user by name.
   * Returns a personalized greeting string.
   */
  query(key: "hello", input: string): Promise<string>;
  query(key: "hello", input: string, options: CallOptions): Promise<string>;
  query(key: "init_demo", input: AppState): Promise<InitDemoResponse>;
  query(key: "init_demo", input: AppState, options: CallOptions): Promise<InitDemoResponse>;
  /** Perform a math operation. Returns an error on division by zero. */
  query(key: "math", input: MathInput): Promise<MathResult>;
  query(key: "math", input: MathInput, options: CallOptions): Promise<MathResult>;
  /**
   * Look up a user profile by ID.
   * 
   * Showcases serde attributes: `rename_all`, `rename`, `skip`, `default`
   * on structs and enums to demonstrate TypeScript codegen fidelity.
   */
  query(key: "profile", input: number): Promise<UserProfile>;
  query(key: "profile", input: number, options: CallOptions): Promise<UserProfile>;
  /** Compute descriptive statistics for a list of numbers. */
  query(key: "stats", input: number[]): Promise<Stats>;
  query(key: "stats", input: number[], options: CallOptions): Promise<Stats>;
  query(key: "timeout_demo", input: TimeoutDemoInput): Promise<TimeoutDemoResponse>;
  query(key: "timeout_demo", input: TimeoutDemoInput, options: CallOptions): Promise<TimeoutDemoResponse>;

  /** Echo a message back, optionally transforming it to uppercase. */
  mutate(key: "echo", input: EchoInput): Promise<EchoOutput>;
  mutate(key: "echo", input: EchoInput, options: CallOptions): Promise<EchoOutput>;
  /**
   * Idempotent upsert: sets the stored value. Repeated calls with the same
   * input produce the same result, making it safe to retry on failure.
   */
  mutate(key: "idempotent_demo", input: IdempotentDemoInput): Promise<IdempotentDemoResponse>;
  mutate(key: "idempotent_demo", input: IdempotentDemoInput, options: CallOptions): Promise<IdempotentDemoResponse>;
}

export function createRpcClient(config: RpcClientConfig): RpcClient {
  const inflight = new Map<string, Promise<unknown>>();

  return {
    query(key: QueryKey, ...args: unknown[]): Promise<unknown> {
      let input: unknown;
      let callOptions: CallOptions | undefined;
      if (VOID_QUERIES.has(key)) {
        input = undefined;
        callOptions = args[0] as CallOptions | undefined;
      } else {
        input = args[0];
        callOptions = args[1] as CallOptions | undefined;
      }
      const shouldDedupe = callOptions?.dedupe ?? config.dedupe ?? true;
      if (shouldDedupe) {
        const k = dedupKey(key, input, config);
        const existing = inflight.get(k);
        if (existing) return wrapWithSignal(existing, callOptions?.signal);
        const promise = rpcFetch(config, "GET", key, input, callOptions)
          .finally(() => inflight.delete(k));
        inflight.set(k, promise);
        return wrapWithSignal(promise, callOptions?.signal);
      }
      return rpcFetch(config, "GET", key, input, callOptions);
    },
    mutate(key: MutationKey, ...args: unknown[]): Promise<unknown> {
      return rpcFetch(config, "POST", key, args[0], args[1] as CallOptions | undefined);
    },
  } as RpcClient;
}
