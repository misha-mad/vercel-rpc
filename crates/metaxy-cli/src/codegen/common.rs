//! Shared logic for framework-specific codegen files (React, Svelte, Vue, SolidJS).
//!
//! Each framework wrapper follows the same structure: imports, type helpers,
//! void/non-void key unions, interface definitions, query/mutation overloads,
//! and implementation blocks. This module extracts all the common patterns
//! so that individual framework modules only supply their unique constants.

use crate::model::{Manifest, Procedure, ProcedureKind};

/// Header comment included at the top of every generated file.
pub const GENERATED_HEADER: &str = "\
// This file is auto-generated by metaxy-cli. Do not edit manually.
// Re-run `metaxy generate` or use `metaxy watch` to regenerate.
";

/// Returns `true` if the procedure takes no input (void).
pub fn is_void_input(proc: &Procedure) -> bool {
    proc.input.as_ref().is_none_or(|ty| ty.name == "()")
}

/// Configuration for generating a framework-specific reactive wrapper file.
pub struct FrameworkConfig<'a> {
    /// Framework-specific import line (e.g. `import { useState, ... } from "react";`).
    /// `None` for Svelte which has no framework import.
    pub framework_import: Option<&'a str>,

    /// Name of the query function (e.g. `"useQuery"` or `"createQuery"`).
    pub query_fn_name: &'a str,

    /// Whether non-void query input is a getter `() => QueryInput<K>` (Svelte/Vue/Solid)
    /// or a direct value `QueryInput<K>` (React).
    pub input_as_getter: bool,

    /// TypeScript interface constants for queries (options, result).
    pub query_interfaces: &'a [&'a str],

    /// TypeScript interface constants for mutations (options, result).
    pub mutation_interfaces: &'a [&'a str],

    /// Query implementation block (TypeScript source).
    pub query_impl: &'a str,

    /// Mutation implementation block (TypeScript source).
    pub mutation_impl: &'a str,
}

/// Generates a complete framework-specific reactive wrapper file.
///
/// Returns an empty string when the manifest contains no procedures.
pub fn generate_framework_file(
    manifest: &Manifest,
    client_import_path: &str,
    types_import_path: &str,
    _preserve_docs: bool,
    config: &FrameworkConfig<'_>,
) -> String {
    let queries: Vec<_> = manifest
        .procedures
        .iter()
        .filter(|p| p.kind == ProcedureKind::Query)
        .collect();
    let mutations: Vec<_> = manifest
        .procedures
        .iter()
        .filter(|p| p.kind == ProcedureKind::Mutation)
        .collect();

    if queries.is_empty() && mutations.is_empty() {
        return String::new();
    }

    let has_queries = !queries.is_empty();
    let has_mutations = !mutations.is_empty();

    let mut out = String::with_capacity(4096);

    // Header
    out.push_str(GENERATED_HEADER);
    out.push('\n');

    // Framework import (if any)
    if let Some(import) = config.framework_import {
        emit!(out, "{import}\n");
    }

    // Client import
    emit!(
        out,
        "import {{ type RpcClient, RpcError, type CallOptions }} from \"{client_import_path}\";\n"
    );

    // Types import + re-exports
    let type_names: Vec<&str> = manifest
        .structs
        .iter()
        .map(|s| s.name.as_str())
        .chain(manifest.enums.iter().map(|e| e.name.as_str()))
        .collect();

    emit_types_import(&mut out, &type_names, types_import_path);
    emit_re_exports(&mut out, &type_names);

    // Type helpers
    emit_type_helpers(&mut out, has_queries, has_mutations);
    out.push('\n');

    // Void/non-void key unions + MutationArgs
    emit_key_unions_and_args(&mut out, &queries, &mutations, has_queries, has_mutations);
    out.push('\n');

    // Interfaces
    if has_queries {
        for iface in config.query_interfaces {
            emit!(out, "{iface}\n");
        }
    }
    if has_mutations {
        for iface in config.mutation_interfaces {
            emit!(out, "{iface}\n");
        }
    }

    // Query overloads + implementation
    if has_queries {
        let void_names: Vec<_> = queries
            .iter()
            .filter(|p| is_void_input(p))
            .map(|p| format!("\"{}\"", p.name))
            .collect();
        emit!(
            out,
            "const VOID_QUERY_KEYS: Set<QueryKey> = new Set([{}]);\n",
            void_names.join(", ")
        );
        emit_query_overloads(
            &queries,
            config.query_fn_name,
            config.input_as_getter,
            &mut out,
        );
        emit!(out, "{}\n", config.query_impl);
    }

    // Mutation implementation
    if has_mutations {
        emit!(out, "{}\n", config.mutation_impl);
    }

    out
}

/// Emits the `import type { Procedures, ... }` line.
fn emit_types_import(out: &mut String, type_names: &[&str], types_import_path: &str) {
    if type_names.is_empty() {
        emit!(
            out,
            "import type {{ Procedures }} from \"{types_import_path}\";\n"
        );
    } else {
        let types_csv = type_names.join(", ");
        emit!(
            out,
            "import type {{ Procedures, {types_csv} }} from \"{types_import_path}\";\n"
        );
    }
}

/// Emits re-exports: `export { RpcError }` and `export type { ... }`.
fn emit_re_exports(out: &mut String, type_names: &[&str]) {
    emit!(out, "export {{ RpcError }};");
    if type_names.is_empty() {
        emit!(
            out,
            "export type {{ RpcClient, CallOptions, Procedures }};\n"
        );
    } else {
        let types_csv = type_names.join(", ");
        emit!(
            out,
            "export type {{ RpcClient, CallOptions, Procedures, {types_csv} }};\n"
        );
    }
}

/// Emits QueryKey/MutationKey type aliases and their Input/Output helpers.
fn emit_type_helpers(out: &mut String, has_queries: bool, has_mutations: bool) {
    if has_queries {
        emit!(out, "type QueryKey = keyof Procedures[\"queries\"];");
        emit!(
            out,
            "type QueryInput<K extends QueryKey> = Procedures[\"queries\"][K][\"input\"];"
        );
        emit!(
            out,
            "type QueryOutput<K extends QueryKey> = Procedures[\"queries\"][K][\"output\"];"
        );
    }
    if has_mutations {
        emit!(out, "type MutationKey = keyof Procedures[\"mutations\"];");
        emit!(
            out,
            "type MutationInput<K extends MutationKey> = Procedures[\"mutations\"][K][\"input\"];"
        );
        emit!(
            out,
            "type MutationOutput<K extends MutationKey> = Procedures[\"mutations\"][K][\"output\"];"
        );
    }
}

/// Emits VoidQueryKey/NonVoidQueryKey unions and the MutationArgs conditional type.
fn emit_key_unions_and_args(
    out: &mut String,
    queries: &[&Procedure],
    mutations: &[&Procedure],
    has_queries: bool,
    has_mutations: bool,
) {
    if has_queries {
        let void_queries: Vec<_> = queries.iter().filter(|p| is_void_input(p)).collect();
        let non_void_queries: Vec<_> = queries.iter().filter(|p| !is_void_input(p)).collect();

        if !void_queries.is_empty() {
            let names: Vec<_> = void_queries
                .iter()
                .map(|p| format!("\"{}\"", p.name))
                .collect();
            emit!(out, "type VoidQueryKey = {};", names.join(" | "));
        }
        if !non_void_queries.is_empty() {
            let names: Vec<_> = non_void_queries
                .iter()
                .map(|p| format!("\"{}\"", p.name))
                .collect();
            emit!(out, "type NonVoidQueryKey = {};", names.join(" | "));
        }
    }

    if has_mutations {
        let void_mutations: Vec<_> = mutations.iter().filter(|p| is_void_input(p)).collect();
        let non_void_mutations: Vec<_> = mutations.iter().filter(|p| !is_void_input(p)).collect();

        if !void_mutations.is_empty() {
            let names: Vec<_> = void_mutations
                .iter()
                .map(|p| format!("\"{}\"", p.name))
                .collect();
            emit!(out, "type VoidMutationKey = {};", names.join(" | "));
        }
        if !non_void_mutations.is_empty() {
            let names: Vec<_> = non_void_mutations
                .iter()
                .map(|p| format!("\"{}\"", p.name))
                .collect();
            emit!(out, "type NonVoidMutationKey = {};", names.join(" | "));
        }

        let all_void = non_void_mutations.is_empty();
        let all_non_void = void_mutations.is_empty();
        if all_void {
            emit!(out, "type MutationArgs<K extends MutationKey> = [];");
        } else if all_non_void {
            emit!(
                out,
                "type MutationArgs<K extends MutationKey> = [input: MutationInput<K>];"
            );
        } else {
            emit!(
                out,
                "type MutationArgs<K extends MutationKey> = K extends VoidMutationKey ? [] : [input: MutationInput<K>];"
            );
        }
    }
}

/// Emits overload signatures for the query function.
///
/// `fn_name` is the function name (e.g. `"useQuery"` or `"createQuery"`).
/// When `input_as_getter` is true, non-void input is `() => QueryInput<K>`.
fn emit_query_overloads(
    queries: &[&Procedure],
    fn_name: &str,
    input_as_getter: bool,
    out: &mut String,
) {
    let (void_queries, non_void_queries): (Vec<&&Procedure>, Vec<&&Procedure>) =
        queries.iter().partition(|p| is_void_input(p));

    for proc in &void_queries {
        emit!(
            out,
            "export function {fn_name}<K extends \"{}\">(client: RpcClient, key: K, options?: QueryOptions<K> | (() => QueryOptions<K>)): QueryResult<K>;",
            proc.name,
        );
    }

    let input_type = if input_as_getter {
        "() => QueryInput<K>"
    } else {
        "QueryInput<K>"
    };

    for proc in &non_void_queries {
        emit!(
            out,
            "export function {fn_name}<K extends \"{}\">(client: RpcClient, key: K, input: {input_type}, options?: QueryOptions<K> | (() => QueryOptions<K>)): QueryResult<K>;",
            proc.name,
        );
    }
}
