---
source: crates/metaxy-cli/tests/vue.rs
expression: output
---
// This file is auto-generated by metaxy-cli. Do not edit manually.
// Re-run `metaxy generate` or use `metaxy watch` to regenerate.

import { ref, computed, watch, onScopeDispose, type Ref, type ComputedRef } from "vue";

import { type RpcClient, RpcError, type CallOptions } from "./rpc-client";

import type { Procedures } from "./rpc-types";

export { RpcError };
export type { RpcClient, CallOptions, Procedures };

type MutationKey = keyof Procedures["mutations"];
type MutationInput<K extends MutationKey> = Procedures["mutations"][K]["input"];
type MutationOutput<K extends MutationKey> = Procedures["mutations"][K]["output"];

type VoidMutationKey = "reset";
type NonVoidMutationKey = "create_item";
type MutationArgs<K extends MutationKey> = K extends VoidMutationKey ? [] : [input: MutationInput<K>];

export interface MutationOptions<K extends MutationKey> {
  /** Per-call options forwarded to client.mutate(). */
  callOptions?: CallOptions;

  /** Called when the mutation succeeds. */
  onSuccess?: (data: MutationOutput<K>) => void;

  /** Called when the mutation fails. */
  onError?: (error: RpcError) => void;

  /** Called when the mutation settles (success or failure). */
  onSettled?: () => void;
}

export interface MutationResult<K extends MutationKey> {
  /** Execute the mutation. Rejects on error. */
  mutate: (...args: MutationArgs<K>) => Promise<void>;

  /** Execute the mutation and return the result. Rejects on error. */
  mutateAsync: (...args: MutationArgs<K>) => Promise<MutationOutput<K>>;

  /** The latest successfully resolved data. */
  readonly data: Ref<MutationOutput<K> | undefined>;

  /** The error from the most recent failed mutation, cleared on next attempt. */
  readonly error: Ref<RpcError | undefined>;

  /** True while a mutation is in-flight. */
  readonly isLoading: Ref<boolean>;

  /** True after the most recent mutation succeeded. */
  readonly isSuccess: ComputedRef<boolean>;

  /** True when the most recent mutation failed. */
  readonly isError: ComputedRef<boolean>;

  /** Reset state back to idle (clear data, error, status). */
  reset: () => void;
}

export function useMutation<K extends MutationKey>(
  client: RpcClient,
  key: K,
  options?: MutationOptions<K>,
): MutationResult<K> {
  const data = ref<MutationOutput<K> | undefined>() as Ref<MutationOutput<K> | undefined>;
  const error = ref<RpcError | undefined>();
  const isLoading = ref(false);
  const hasSucceeded = ref(false);
  const isSuccess = computed(() => hasSucceeded.value);
  const isError = computed(() => error.value !== undefined);

  async function execute(...input: MutationArgs<K>): Promise<MutationOutput<K>> {
    isLoading.value = true;
    error.value = undefined;
    hasSucceeded.value = false;
    try {
      const callArgs: unknown[] = [key];
      if (input.length > 0) callArgs.push(input[0]);
      if (options?.callOptions) callArgs.push(options.callOptions);
      const result = await (client.mutate as (...a: unknown[]) => Promise<unknown>)(
        ...callArgs
      ) as MutationOutput<K>;
      data.value = result;
      hasSucceeded.value = true;
      options?.onSuccess?.(result);
      return result;
    } catch (e) {
      error.value = e as RpcError;
      options?.onError?.(error.value);
      throw e;
    } finally {
      isLoading.value = false;
      options?.onSettled?.();
    }
  }

  return {
    mutate: async (...args: MutationArgs<K>) => { await execute(...args); },
    mutateAsync: (...args: MutationArgs<K>) => execute(...args),
    data,
    error,
    isLoading,
    isSuccess,
    isError,
    reset: () => { data.value = undefined; error.value = undefined; isLoading.value = false; hasSucceeded.value = false; },
  };
}
