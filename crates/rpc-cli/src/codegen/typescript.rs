use crate::config::FieldNaming;
use crate::model::{
    EnumDef, EnumVariant, FieldDef, Manifest, Procedure, ProcedureKind, RenameRule, RustType,
    StructDef, VariantKind,
};

// Header comment included at the top of every generated file.
const GENERATED_HEADER: &str = "\
// This file is auto-generated by vercel-rpc-cli. Do not edit manually.
// Re-run `rpc generate` or use `rpc watch` to regenerate.
";

/// Converts a `RustType` into its TypeScript equivalent.
///
/// Mapping rules:
/// - Rust primitives (`String`, `str`, `char`) → `string`
/// - Numeric types (`i8`..`i128`, `u8`..`u128`, `f32`, `f64`, `isize`, `usize`) → `number`
/// - `bool` → `boolean`
/// - `()` → `void`
/// - `Vec<T>`, `Array<T>`, `HashSet<T>`, `BTreeSet<T>` → `T[]`
/// - `Option<T>` → `T | null`
/// - `HashMap<K, V>`, `BTreeMap<K, V>` → `Record<K, V>`
/// - `Box<T>`, `Arc<T>`, `Rc<T>`, `Cow<T>` → `T` (transparent wrappers)
/// - `tuple(A, B, ...)` → `[A, B, ...]`
/// - Everything else (user-defined structs) → kept as-is
pub fn rust_type_to_ts(ty: &RustType) -> String {
    match ty.name.as_str() {
        // Unit type
        "()" => "void".to_string(),

        // String types
        "String" | "str" | "char" | "&str" => "string".to_string(),

        // Boolean
        "bool" => "boolean".to_string(),

        // Numeric types
        "i8" | "i16" | "i32" | "i64" | "i128" | "u8" | "u16" | "u32" | "u64" | "u128" | "f32"
        | "f64" | "isize" | "usize" => "number".to_string(),

        // Vec / Array / Set types → T[]
        "Vec" | "Array" | "HashSet" | "BTreeSet" => {
            let inner = ty
                .generics
                .first()
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "unknown".to_string());
            // Wrap union types in parens for correct precedence: `(A | B)[]`
            if inner.contains(" | ") {
                format!("({inner})[]")
            } else {
                format!("{inner}[]")
            }
        }

        // Option<T> → T | null
        "Option" => {
            let inner = ty
                .generics
                .first()
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "unknown".to_string());
            format!("{inner} | null")
        }

        // HashMap / BTreeMap → Record<K, V>
        "HashMap" | "BTreeMap" => {
            let key = ty
                .generics
                .first()
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "string".to_string());
            let value = ty
                .generics
                .get(1)
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "unknown".to_string());
            format!("Record<{key}, {value}>")
        }

        // Smart pointers / wrappers → unwrap to inner type
        "Box" | "Arc" | "Rc" | "Cow" => ty
            .generics
            .first()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "unknown".to_string()),

        // Tuple → [A, B, ...]
        "tuple" => {
            let elems: Vec<String> = ty.generics.iter().map(rust_type_to_ts).collect();
            format!("[{}]", elems.join(", "))
        }

        // User-defined types or unknown — pass through as-is
        other => other.to_string(),
    }
}

/// Emits a JSDoc comment block from a doc string.
pub fn emit_jsdoc(doc: &str, indent: &str, out: &mut String) {
    if !doc.contains('\n') {
        emit!(out, "{indent}/** {doc} */");
    } else {
        emit!(out, "{indent}/**");
        for line in doc.lines() {
            emit!(out, "{indent} * {line}");
        }
        emit!(out, "{indent} */");
    }
}

/// Converts a snake_case string to camelCase.
pub fn to_camel_case(s: &str) -> String {
    let mut segments = s.split('_');
    let mut result = segments
        .next()
        .expect("split always yields at least one element")
        .to_lowercase();
    for segment in segments {
        let mut chars = segment.chars();
        if let Some(first) = chars.next() {
            result.extend(first.to_uppercase());
            result.push_str(&chars.as_str().to_lowercase());
        }
    }
    result
}

/// Transforms a field name according to the naming strategy.
fn transform_field_name(name: &str, naming: FieldNaming) -> String {
    match naming {
        FieldNaming::Preserve => name.to_string(),
        FieldNaming::CamelCase => to_camel_case(name),
    }
}

/// Resolves the final output name for a struct/variant field.
///
/// Priority: field `rename` > container `rename_all` > config `field_naming` > original name.
fn resolve_field_name(
    field: &FieldDef,
    container_rename_all: Option<RenameRule>,
    config_naming: FieldNaming,
) -> String {
    if let Some(rename) = &field.rename {
        return rename.clone();
    }
    if let Some(rule) = container_rename_all {
        return rule.apply(&field.name);
    }
    transform_field_name(&field.name, config_naming)
}

/// Resolves the final output name for an enum variant.
///
/// Priority: variant `rename` > container `rename_all` > original name.
fn resolve_variant_name(variant: &EnumVariant, container_rename_all: Option<RenameRule>) -> String {
    if let Some(rename) = &variant.rename {
        return rename.clone();
    }
    if let Some(rule) = container_rename_all {
        return rule.apply(&variant.name);
    }
    variant.name.clone()
}

/// Returns the inner type of `Option<T>`, or `None` if not an Option.
fn option_inner_type(ty: &RustType) -> Option<&RustType> {
    if ty.name == "Option" {
        ty.generics.first()
    } else {
        None
    }
}

/// Generates a TypeScript interface from a struct definition.
fn generate_interface(
    s: &StructDef,
    preserve_docs: bool,
    field_naming: FieldNaming,
    out: &mut String,
) {
    if preserve_docs && let Some(doc) = &s.docs {
        emit_jsdoc(doc, "", out);
    }
    emit!(out, "export interface {} {{", s.name);
    for field in &s.fields {
        if field.skip {
            continue;
        }
        let field_name = resolve_field_name(field, s.rename_all, field_naming);
        if field.has_default
            && let Some(inner) = option_inner_type(&field.ty)
        {
            let ts_type = rust_type_to_ts(inner);
            emit!(out, "  {field_name}?: {ts_type} | null;");
            continue;
        }
        let ts_type = rust_type_to_ts(&field.ty);
        emit!(out, "  {field_name}: {ts_type};");
    }
    emit!(out, "}}");
}

/// Generates a TypeScript type from an enum definition.
///
/// Supports three variant shapes following serde's default (externally tagged) representation:
/// - Unit variants → string literal union: `"Active" | "Inactive"`
/// - Tuple variants → `{ VariantName: T }` (single field) or `{ VariantName: [A, B] }` (multiple)
/// - Struct variants → `{ VariantName: { field: type } }`
///
/// If all variants are unit, emits a simple string union.
/// Otherwise, emits a discriminated union of object types.
fn generate_enum_type(
    e: &EnumDef,
    preserve_docs: bool,
    field_naming: FieldNaming,
    out: &mut String,
) {
    if preserve_docs && let Some(doc) = &e.docs {
        emit_jsdoc(doc, "", out);
    }
    let all_unit = e
        .variants
        .iter()
        .all(|v| matches!(v.kind, VariantKind::Unit));

    if all_unit {
        // Simple string literal union
        let variants: Vec<String> = e
            .variants
            .iter()
            .map(|v| {
                let name = resolve_variant_name(v, e.rename_all);
                format!("\"{name}\"")
            })
            .collect();
        if variants.is_empty() {
            emit!(out, "export type {} = never;", e.name);
        } else {
            emit!(out, "export type {} = {};", e.name, variants.join(" | "));
        }
    } else {
        // Tagged union (serde externally tagged default)
        let mut variant_types: Vec<String> = Vec::new();

        for v in &e.variants {
            let variant_name = resolve_variant_name(v, e.rename_all);
            match &v.kind {
                VariantKind::Unit => {
                    variant_types.push(format!("\"{variant_name}\""));
                }
                VariantKind::Tuple(types) => {
                    let inner = if types.len() == 1 {
                        rust_type_to_ts(&types[0])
                    } else {
                        let elems: Vec<String> = types.iter().map(rust_type_to_ts).collect();
                        format!("[{}]", elems.join(", "))
                    };
                    variant_types.push(format!("{{ {variant_name}: {inner} }}"));
                }
                VariantKind::Struct(fields) => {
                    // Serde applies the container-level rename_all to struct variant
                    // fields as well, so we pass e.rename_all here intentionally.
                    let field_strs: Vec<String> = fields
                        .iter()
                        .filter(|f| !f.skip)
                        .map(|field| {
                            let field_name = resolve_field_name(field, e.rename_all, field_naming);
                            format!("{}: {}", field_name, rust_type_to_ts(&field.ty))
                        })
                        .collect();
                    variant_types.push(format!(
                        "{{ {variant_name}: {{ {} }} }}",
                        field_strs.join("; ")
                    ));
                }
            }
        }

        emit!(
            out,
            "export type {} = {};",
            e.name,
            variant_types.join(" | ")
        );
    }
}

/// Generates the `Procedures` type that maps procedure names to their input/output types,
/// grouped by kind (queries / mutations).
fn generate_procedures_type(procedures: &[Procedure], preserve_docs: bool, out: &mut String) {
    let (queries, mutations): (Vec<_>, Vec<_>) = procedures
        .iter()
        .partition(|p| p.kind == ProcedureKind::Query);

    emit!(out, "export type Procedures = {{");

    // Queries
    emit!(out, "  queries: {{");
    for proc in &queries {
        if preserve_docs && let Some(doc) = &proc.docs {
            emit_jsdoc(doc, "    ", out);
        }
        let input = proc
            .input
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let output = proc
            .output
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        emit!(
            out,
            "    {}: {{ input: {input}; output: {output} }};",
            proc.name
        );
    }
    emit!(out, "  }};");

    // Mutations
    emit!(out, "  mutations: {{");
    for proc in &mutations {
        if preserve_docs && let Some(doc) = &proc.docs {
            emit_jsdoc(doc, "    ", out);
        }
        let input = proc
            .input
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let output = proc
            .output
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        emit!(
            out,
            "    {}: {{ input: {input}; output: {output} }};",
            proc.name
        );
    }
    emit!(out, "  }};");

    emit!(out, "}};");
}

/// Generates the complete `rpc-types.ts` file content from a manifest.
///
/// The output includes:
/// 1. Auto-generation header
/// 2. TypeScript interfaces for all referenced structs
/// 3. The `Procedures` type mapping
pub fn generate_types_file(
    manifest: &Manifest,
    preserve_docs: bool,
    field_naming: FieldNaming,
) -> String {
    let mut out = String::with_capacity(1024);

    // Header
    out.push_str(GENERATED_HEADER);
    out.push('\n');

    // Emit all structs discovered in the scanned files.
    for s in &manifest.structs {
        generate_interface(s, preserve_docs, field_naming, &mut out);
        out.push('\n');
    }

    // Emit all enums discovered in the scanned files.
    for e in &manifest.enums {
        generate_enum_type(e, preserve_docs, field_naming, &mut out);
        out.push('\n');
    }

    // Generate the Procedures type
    generate_procedures_type(&manifest.procedures, preserve_docs, &mut out);

    out
}
