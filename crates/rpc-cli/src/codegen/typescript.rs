use std::fmt::Write;

use crate::model::{Manifest, Procedure, ProcedureKind, RustType, StructDef};

// Header comment included at the top of every generated file.
const GENERATED_HEADER: &str = "\
// This file is auto-generated by vercel-rpc-cli. Do not edit manually.
// Re-run `rpc generate` or use `rpc watch` to regenerate.
";

/// Converts a `RustType` into its TypeScript equivalent.
///
/// Mapping rules:
/// - Rust primitives (`String`, `str`, `char`) → `string`
/// - Numeric types (`i8`..`i128`, `u8`..`u128`, `f32`, `f64`, `isize`, `usize`) → `number`
/// - `bool` → `boolean`
/// - `()` → `void`
/// - `Vec<T>`, `Array<T>` → `T[]`
/// - `Option<T>` → `T | null`
/// - `HashMap<K, V>`, `BTreeMap<K, V>` → `Record<K, V>`
/// - `tuple(A, B, ...)` → `[A, B, ...]`
/// - Everything else (user-defined structs) → kept as-is
pub fn rust_type_to_ts(ty: &RustType) -> String {
    match ty.name.as_str() {
        // Unit type
        "()" => "void".to_string(),

        // String types
        "String" | "str" | "char" | "&str" => "string".to_string(),

        // Boolean
        "bool" => "boolean".to_string(),

        // Numeric types
        "i8" | "i16" | "i32" | "i64" | "i128" | "u8" | "u16" | "u32" | "u64" | "u128"
        | "f32" | "f64" | "isize" | "usize" => "number".to_string(),

        // Vec / Array → T[]
        "Vec" | "Array" => {
            let inner = ty
                .generics
                .first()
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "unknown".to_string());
            // Wrap union types in parens for correct precedence: `(A | B)[]`
            if inner.contains(" | ") {
                format!("({inner})[]")
            } else {
                format!("{inner}[]")
            }
        }

        // Option<T> → T | null
        "Option" => {
            let inner = ty
                .generics
                .first()
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "unknown".to_string());
            format!("{inner} | null")
        }

        // HashMap / BTreeMap → Record<K, V>
        "HashMap" | "BTreeMap" => {
            let key = ty
                .generics
                .first()
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "string".to_string());
            let value = ty
                .generics
                .get(1)
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "unknown".to_string());
            format!("Record<{key}, {value}>")
        }

        // Tuple → [A, B, ...]
        "tuple" => {
            let elems: Vec<String> = ty.generics.iter().map(rust_type_to_ts).collect();
            format!("[{}]", elems.join(", "))
        }

        // User-defined types or unknown — pass through as-is
        other => other.to_string(),
    }
}

/// Generates a TypeScript interface from a struct definition.
fn generate_interface(s: &StructDef, out: &mut String) {
    let _ = writeln!(out, "export interface {} {{", s.name);
    for (name, ty) in &s.fields {
        let ts_type = rust_type_to_ts(ty);
        let _ = writeln!(out, "  {name}: {ts_type};");
    }
    let _ = writeln!(out, "}}");
}

/// Generates the `Procedures` type that maps procedure names to their input/output types,
/// grouped by kind (queries / mutations).
fn generate_procedures_type(procedures: &[Procedure], out: &mut String) {
    let queries: Vec<&Procedure> = procedures
        .iter()
        .filter(|p| p.kind == ProcedureKind::Query)
        .collect();
    let mutations: Vec<&Procedure> = procedures
        .iter()
        .filter(|p| p.kind == ProcedureKind::Mutation)
        .collect();

    let _ = writeln!(out, "export type Procedures = {{");

    // Queries
    let _ = writeln!(out, "  queries: {{");
    for proc in &queries {
        let input = proc
            .input
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let output = proc
            .output
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let _ = writeln!(out, "    {}: {{ input: {input}; output: {output} }};", proc.name);
    }
    let _ = writeln!(out, "  }};");

    // Mutations
    let _ = writeln!(out, "  mutations: {{");
    for proc in &mutations {
        let input = proc
            .input
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let output = proc
            .output
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let _ = writeln!(out, "    {}: {{ input: {input}; output: {output} }};", proc.name);
    }
    let _ = writeln!(out, "  }};");

    let _ = writeln!(out, "}};");
}

/// Generates the complete `rpc-types.ts` file content from a manifest.
///
/// The output includes:
/// 1. Auto-generation header
/// 2. TypeScript interfaces for all referenced structs
/// 3. The `Procedures` type mapping
pub fn generate_types_file(manifest: &Manifest) -> String {
    let mut out = String::with_capacity(1024);

    // Header
    out.push_str(GENERATED_HEADER);
    out.push('\n');

    // Emit all structs discovered in the scanned files.
    // Even if a struct isn't directly referenced by a procedure, it may be
    // used transitively or by client code, so we include everything.
    let structs_to_emit: Vec<&StructDef> = manifest.structs.iter().collect();

    if !structs_to_emit.is_empty() {
        for s in &structs_to_emit {
            generate_interface(s, &mut out);
            out.push('\n');
        }
    }

    // Generate the Procedures type
    generate_procedures_type(&manifest.procedures, &mut out);

    out
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::model::*;
    use std::path::PathBuf;

    // --- rust_type_to_ts ---

    #[test]
    fn maps_string_types() {
        assert_eq!(rust_type_to_ts(&RustType::simple("String")), "string");
        assert_eq!(rust_type_to_ts(&RustType::simple("str")), "string");
        assert_eq!(rust_type_to_ts(&RustType::simple("char")), "string");
    }

    #[test]
    fn maps_numeric_types() {
        for name in ["i8", "i16", "i32", "i64", "u8", "u16", "u32", "u64", "f32", "f64", "usize", "isize"] {
            assert_eq!(rust_type_to_ts(&RustType::simple(name)), "number", "failed for {name}");
        }
    }

    #[test]
    fn maps_bool() {
        assert_eq!(rust_type_to_ts(&RustType::simple("bool")), "boolean");
    }

    #[test]
    fn maps_unit() {
        assert_eq!(rust_type_to_ts(&RustType::simple("()")), "void");
    }

    #[test]
    fn maps_vec() {
        let ty = RustType::with_generics("Vec", vec![RustType::simple("String")]);
        assert_eq!(rust_type_to_ts(&ty), "string[]");
    }

    #[test]
    fn maps_vec_of_option() {
        let inner = RustType::with_generics("Option", vec![RustType::simple("i32")]);
        let ty = RustType::with_generics("Vec", vec![inner]);
        assert_eq!(rust_type_to_ts(&ty), "(number | null)[]");
    }

    #[test]
    fn maps_option() {
        let ty = RustType::with_generics("Option", vec![RustType::simple("String")]);
        assert_eq!(rust_type_to_ts(&ty), "string | null");
    }

    #[test]
    fn maps_hashmap() {
        let ty = RustType::with_generics(
            "HashMap",
            vec![RustType::simple("String"), RustType::simple("i32")],
        );
        assert_eq!(rust_type_to_ts(&ty), "Record<string, number>");
    }

    #[test]
    fn maps_btreemap() {
        let ty = RustType::with_generics(
            "BTreeMap",
            vec![RustType::simple("String"), RustType::simple("bool")],
        );
        assert_eq!(rust_type_to_ts(&ty), "Record<string, boolean>");
    }

    #[test]
    fn maps_tuple() {
        let ty = RustType::with_generics(
            "tuple",
            vec![RustType::simple("String"), RustType::simple("i32")],
        );
        assert_eq!(rust_type_to_ts(&ty), "[string, number]");
    }

    #[test]
    fn maps_custom_struct() {
        assert_eq!(rust_type_to_ts(&RustType::simple("TimeResponse")), "TimeResponse");
    }

    #[test]
    fn maps_nested_generics() {
        // Option<Vec<String>> → string[] | null
        let ty = RustType::with_generics(
            "Option",
            vec![RustType::with_generics("Vec", vec![RustType::simple("String")])],
        );
        assert_eq!(rust_type_to_ts(&ty), "string[] | null");
    }

    // --- generate_types_file ---

    fn make_test_manifest() -> Manifest {
        Manifest {
            procedures: vec![
                Procedure {
                    name: "hello".to_string(),
                    kind: ProcedureKind::Query,
                    input: Some(RustType::simple("String")),
                    output: Some(RustType::simple("String")),
                    source_file: PathBuf::from("api/hello.rs"),
                },
                Procedure {
                    name: "time".to_string(),
                    kind: ProcedureKind::Query,
                    input: None,
                    output: Some(RustType::simple("TimeResponse")),
                    source_file: PathBuf::from("api/time.rs"),
                },
                Procedure {
                    name: "create_item".to_string(),
                    kind: ProcedureKind::Mutation,
                    input: Some(RustType::simple("CreateInput")),
                    output: Some(RustType::simple("Item")),
                    source_file: PathBuf::from("api/create_item.rs"),
                },
            ],
            structs: vec![
                StructDef {
                    name: "TimeResponse".to_string(),
                    fields: vec![
                        ("timestamp".to_string(), RustType::simple("u64")),
                        ("message".to_string(), RustType::simple("String")),
                    ],
                    source_file: PathBuf::from("api/time.rs"),
                },
                StructDef {
                    name: "CreateInput".to_string(),
                    fields: vec![
                        ("title".to_string(), RustType::simple("String")),
                        ("count".to_string(), RustType::simple("i32")),
                    ],
                    source_file: PathBuf::from("api/create_item.rs"),
                },
                StructDef {
                    name: "Item".to_string(),
                    fields: vec![
                        ("id".to_string(), RustType::simple("u64")),
                        ("title".to_string(), RustType::simple("String")),
                        ("tags".to_string(), RustType::with_generics("Vec", vec![RustType::simple("String")])),
                    ],
                    source_file: PathBuf::from("api/create_item.rs"),
                },
            ],
        }
    }

    #[test]
    fn generates_complete_types_file() {
        let manifest = make_test_manifest();
        let output = generate_types_file(&manifest);

        // Header present
        assert!(output.starts_with("// This file is auto-generated"));

        // Interfaces generated
        assert!(output.contains("export interface TimeResponse {"));
        assert!(output.contains("  timestamp: number;"));
        assert!(output.contains("  message: string;"));

        assert!(output.contains("export interface CreateInput {"));
        assert!(output.contains("  title: string;"));
        assert!(output.contains("  count: number;"));

        assert!(output.contains("export interface Item {"));
        assert!(output.contains("  id: number;"));
        assert!(output.contains("  tags: string[];"));

        // Procedures type
        assert!(output.contains("export type Procedures = {"));
        assert!(output.contains("  queries: {"));
        assert!(output.contains("    hello: { input: string; output: string };"));
        assert!(output.contains("    time: { input: void; output: TimeResponse };"));
        assert!(output.contains("  mutations: {"));
        assert!(output.contains("    create_item: { input: CreateInput; output: Item };"));
    }

    #[test]
    fn generates_empty_manifest() {
        let manifest = Manifest::default();
        let output = generate_types_file(&manifest);

        assert!(output.contains("queries: {"));
        assert!(output.contains("mutations: {"));
        // No interfaces
        assert!(!output.contains("export interface"));
    }

    #[test]
    fn generates_queries_only() {
        let manifest = Manifest {
            procedures: vec![Procedure {
                name: "ping".to_string(),
                kind: ProcedureKind::Query,
                input: None,
                output: Some(RustType::simple("String")),
                source_file: PathBuf::from("api/ping.rs"),
            }],
            structs: vec![],
        };
        let output = generate_types_file(&manifest);

        assert!(output.contains("    ping: { input: void; output: string };"));
        assert!(!output.contains("export interface"));
    }

    #[test]
    fn generates_complex_nested_types() {
        let manifest = Manifest {
            procedures: vec![Procedure {
                name: "search".to_string(),
                kind: ProcedureKind::Query,
                input: Some(RustType::simple("String")),
                output: Some(RustType::with_generics(
                    "Vec",
                    vec![RustType::with_generics(
                        "Option",
                        vec![RustType::simple("Item")],
                    )],
                )),
                source_file: PathBuf::from("api/search.rs"),
            }],
            structs: vec![],
        };
        let output = generate_types_file(&manifest);
        assert!(output.contains("    search: { input: string; output: (Item | null)[] };"));
    }
}
