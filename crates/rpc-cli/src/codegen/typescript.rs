use std::fmt::Write;

use crate::config::FieldNaming;
use crate::model::{EnumDef, Manifest, Procedure, ProcedureKind, RustType, StructDef, VariantKind};

// Header comment included at the top of every generated file.
const GENERATED_HEADER: &str = "\
// This file is auto-generated by vercel-rpc-cli. Do not edit manually.
// Re-run `rpc generate` or use `rpc watch` to regenerate.
";

/// Converts a `RustType` into its TypeScript equivalent.
///
/// Mapping rules:
/// - Rust primitives (`String`, `str`, `char`) → `string`
/// - Numeric types (`i8`..`i128`, `u8`..`u128`, `f32`, `f64`, `isize`, `usize`) → `number`
/// - `bool` → `boolean`
/// - `()` → `void`
/// - `Vec<T>`, `Array<T>` → `T[]`
/// - `Option<T>` → `T | null`
/// - `HashMap<K, V>`, `BTreeMap<K, V>` → `Record<K, V>`
/// - `tuple(A, B, ...)` → `[A, B, ...]`
/// - Everything else (user-defined structs) → kept as-is
pub fn rust_type_to_ts(ty: &RustType) -> String {
    match ty.name.as_str() {
        // Unit type
        "()" => "void".to_string(),

        // String types
        "String" | "str" | "char" | "&str" => "string".to_string(),

        // Boolean
        "bool" => "boolean".to_string(),

        // Numeric types
        "i8" | "i16" | "i32" | "i64" | "i128" | "u8" | "u16" | "u32" | "u64" | "u128"
        | "f32" | "f64" | "isize" | "usize" => "number".to_string(),

        // Vec / Array → T[]
        "Vec" | "Array" => {
            let inner = ty
                .generics
                .first()
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "unknown".to_string());
            // Wrap union types in parens for correct precedence: `(A | B)[]`
            if inner.contains(" | ") {
                format!("({inner})[]")
            } else {
                format!("{inner}[]")
            }
        }

        // Option<T> → T | null
        "Option" => {
            let inner = ty
                .generics
                .first()
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "unknown".to_string());
            format!("{inner} | null")
        }

        // HashMap / BTreeMap → Record<K, V>
        "HashMap" | "BTreeMap" => {
            let key = ty
                .generics
                .first()
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "string".to_string());
            let value = ty
                .generics
                .get(1)
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "unknown".to_string());
            format!("Record<{key}, {value}>")
        }

        // Tuple → [A, B, ...]
        "tuple" => {
            let elems: Vec<String> = ty.generics.iter().map(rust_type_to_ts).collect();
            format!("[{}]", elems.join(", "))
        }

        // User-defined types or unknown — pass through as-is
        other => other.to_string(),
    }
}

/// Emits a JSDoc comment block from a doc string.
pub fn emit_jsdoc(doc: &str, indent: &str, out: &mut String) {
    let lines: Vec<&str> = doc.lines().collect();
    if lines.len() == 1 {
        let _ = writeln!(out, "{indent}/** {} */", lines[0]);
    } else {
        let _ = writeln!(out, "{indent}/**");
        for line in &lines {
            let _ = writeln!(out, "{indent} * {line}");
        }
        let _ = writeln!(out, "{indent} */");
    }
}

/// Converts a snake_case string to camelCase.
pub fn to_camel_case(s: &str) -> String {
    let mut segments = s.split('_');
    // split() always yields at least one element
    let mut result = segments.next().unwrap().to_lowercase();
    for segment in segments {
        let mut chars = segment.chars();
        if let Some(first) = chars.next() {
            result.extend(first.to_uppercase());
            result.push_str(&chars.as_str().to_lowercase());
        }
    }
    result
}

/// Transforms a field name according to the naming strategy.
fn transform_field_name(name: &str, naming: FieldNaming) -> String {
    match naming {
        FieldNaming::Preserve => name.to_string(),
        FieldNaming::CamelCase => to_camel_case(name),
    }
}

/// Generates a TypeScript interface from a struct definition.
fn generate_interface(s: &StructDef, preserve_docs: bool, field_naming: FieldNaming, out: &mut String) {
    if preserve_docs
        && let Some(doc) = &s.docs
    {
        emit_jsdoc(doc, "", out);
    }
    let _ = writeln!(out, "export interface {} {{", s.name);
    for (name, ty) in &s.fields {
        let ts_type = rust_type_to_ts(ty);
        let field_name = transform_field_name(name, field_naming);
        let _ = writeln!(out, "  {field_name}: {ts_type};");
    }
    let _ = writeln!(out, "}}");
}

/// Generates a TypeScript type from an enum definition.
///
/// Supports three variant shapes following serde's default (externally tagged) representation:
/// - Unit variants → string literal union: `"Active" | "Inactive"`
/// - Tuple variants → `{ VariantName: T }` (single field) or `{ VariantName: [A, B] }` (multiple)
/// - Struct variants → `{ VariantName: { field: type } }`
///
/// If all variants are unit, emits a simple string union.
/// Otherwise, emits a discriminated union of object types.
fn generate_enum_type(e: &EnumDef, preserve_docs: bool, field_naming: FieldNaming, out: &mut String) {
    if preserve_docs
        && let Some(doc) = &e.docs
    {
        emit_jsdoc(doc, "", out);
    }
    let all_unit = e.variants.iter().all(|v| matches!(v.kind, VariantKind::Unit));

    if all_unit {
        // Simple string literal union
        let variants: Vec<String> = e.variants.iter().map(|v| format!("\"{}\"" , v.name)).collect();
        if variants.is_empty() {
            let _ = writeln!(out, "export type {} = never;", e.name);
        } else {
            let _ = writeln!(out, "export type {} = {};", e.name, variants.join(" | "));
        }
    } else {
        // Tagged union (serde externally tagged default)
        let mut variant_types: Vec<String> = Vec::new();

        for v in &e.variants {
            match &v.kind {
                VariantKind::Unit => {
                    variant_types.push(format!("\"{}\"" , v.name));
                }
                VariantKind::Tuple(types) => {
                    let inner = if types.len() == 1 {
                        rust_type_to_ts(&types[0])
                    } else {
                        let elems: Vec<String> = types.iter().map(rust_type_to_ts).collect();
                        format!("[{}]", elems.join(", "))
                    };
                    variant_types.push(format!("{{ {}: {} }}", v.name, inner));
                }
                VariantKind::Struct(fields) => {
                    let field_strs: Vec<String> = fields
                        .iter()
                        .map(|(name, ty)| {
                            let field_name = transform_field_name(name, field_naming);
                            format!("{}: {}", field_name, rust_type_to_ts(ty))
                        })
                        .collect();
                    variant_types.push(format!("{{ {}: {{ {} }} }}", v.name, field_strs.join("; ")));
                }
            }
        }

        let _ = writeln!(out, "export type {} = {};", e.name, variant_types.join(" | "));
    }
}

/// Generates the `Procedures` type that maps procedure names to their input/output types,
/// grouped by kind (queries / mutations).
fn generate_procedures_type(procedures: &[Procedure], preserve_docs: bool, out: &mut String) {
    let queries: Vec<&Procedure> = procedures
        .iter()
        .filter(|p| p.kind == ProcedureKind::Query)
        .collect();
    let mutations: Vec<&Procedure> = procedures
        .iter()
        .filter(|p| p.kind == ProcedureKind::Mutation)
        .collect();

    let _ = writeln!(out, "export type Procedures = {{");

    // Queries
    let _ = writeln!(out, "  queries: {{");
    for proc in &queries {
        if preserve_docs
            && let Some(doc) = &proc.docs
        {
            emit_jsdoc(doc, "    ", out);
        }
        let input = proc
            .input
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let output = proc
            .output
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let _ = writeln!(out, "    {}: {{ input: {input}; output: {output} }};", proc.name);
    }
    let _ = writeln!(out, "  }};");

    // Mutations
    let _ = writeln!(out, "  mutations: {{");
    for proc in &mutations {
        if preserve_docs
            && let Some(doc) = &proc.docs
        {
            emit_jsdoc(doc, "    ", out);
        }
        let input = proc
            .input
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let output = proc
            .output
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let _ = writeln!(out, "    {}: {{ input: {input}; output: {output} }};", proc.name);
    }
    let _ = writeln!(out, "  }};");

    let _ = writeln!(out, "}};");
}

/// Generates the complete `rpc-types.ts` file content from a manifest.
///
/// The output includes:
/// 1. Auto-generation header
/// 2. TypeScript interfaces for all referenced structs
/// 3. The `Procedures` type mapping
pub fn generate_types_file(manifest: &Manifest, preserve_docs: bool, field_naming: FieldNaming) -> String {
    let mut out = String::with_capacity(1024);

    // Header
    out.push_str(GENERATED_HEADER);
    out.push('\n');

    // Emit all structs discovered in the scanned files.
    for s in &manifest.structs {
        generate_interface(s, preserve_docs, field_naming, &mut out);
        out.push('\n');
    }

    // Emit all enums discovered in the scanned files.
    for e in &manifest.enums {
        generate_enum_type(e, preserve_docs, field_naming, &mut out);
        out.push('\n');
    }

    // Generate the Procedures type
    generate_procedures_type(&manifest.procedures, preserve_docs, &mut out);

    out
}
