use std::fmt::Write;

use crate::config::FieldNaming;
use crate::model::{EnumDef, Manifest, Procedure, ProcedureKind, RustType, StructDef, VariantKind};

// Header comment included at the top of every generated file.
const GENERATED_HEADER: &str = "\
// This file is auto-generated by vercel-rpc-cli. Do not edit manually.
// Re-run `rpc generate` or use `rpc watch` to regenerate.
";

/// Converts a `RustType` into its TypeScript equivalent.
///
/// Mapping rules:
/// - Rust primitives (`String`, `str`, `char`) → `string`
/// - Numeric types (`i8`..`i128`, `u8`..`u128`, `f32`, `f64`, `isize`, `usize`) → `number`
/// - `bool` → `boolean`
/// - `()` → `void`
/// - `Vec<T>`, `Array<T>` → `T[]`
/// - `Option<T>` → `T | null`
/// - `HashMap<K, V>`, `BTreeMap<K, V>` → `Record<K, V>`
/// - `tuple(A, B, ...)` → `[A, B, ...]`
/// - Everything else (user-defined structs) → kept as-is
pub fn rust_type_to_ts(ty: &RustType) -> String {
    match ty.name.as_str() {
        // Unit type
        "()" => "void".to_string(),

        // String types
        "String" | "str" | "char" | "&str" => "string".to_string(),

        // Boolean
        "bool" => "boolean".to_string(),

        // Numeric types
        "i8" | "i16" | "i32" | "i64" | "i128" | "u8" | "u16" | "u32" | "u64" | "u128"
        | "f32" | "f64" | "isize" | "usize" => "number".to_string(),

        // Vec / Array → T[]
        "Vec" | "Array" => {
            let inner = ty
                .generics
                .first()
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "unknown".to_string());
            // Wrap union types in parens for correct precedence: `(A | B)[]`
            if inner.contains(" | ") {
                format!("({inner})[]")
            } else {
                format!("{inner}[]")
            }
        }

        // Option<T> → T | null
        "Option" => {
            let inner = ty
                .generics
                .first()
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "unknown".to_string());
            format!("{inner} | null")
        }

        // HashMap / BTreeMap → Record<K, V>
        "HashMap" | "BTreeMap" => {
            let key = ty
                .generics
                .first()
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "string".to_string());
            let value = ty
                .generics
                .get(1)
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "unknown".to_string());
            format!("Record<{key}, {value}>")
        }

        // Tuple → [A, B, ...]
        "tuple" => {
            let elems: Vec<String> = ty.generics.iter().map(rust_type_to_ts).collect();
            format!("[{}]", elems.join(", "))
        }

        // User-defined types or unknown — pass through as-is
        other => other.to_string(),
    }
}

/// Emits a JSDoc comment block from a doc string.
pub fn emit_jsdoc(doc: &str, indent: &str, out: &mut String) {
    let lines: Vec<&str> = doc.lines().collect();
    if lines.len() == 1 {
        let _ = writeln!(out, "{indent}/** {} */", lines[0]);
    } else {
        let _ = writeln!(out, "{indent}/**");
        for line in &lines {
            let _ = writeln!(out, "{indent} * {line}");
        }
        let _ = writeln!(out, "{indent} */");
    }
}

/// Converts a snake_case string to camelCase.
fn to_camel_case(s: &str) -> String {
    let mut segments = s.split('_');
    let mut result = match segments.next() {
        Some(first) => first.to_lowercase(),
        None => return String::new(),
    };
    for segment in segments {
        let mut chars = segment.chars();
        if let Some(first) = chars.next() {
            result.extend(first.to_uppercase());
            result.push_str(&chars.as_str().to_lowercase());
        }
    }
    result
}

/// Transforms a field name according to the naming strategy.
fn transform_field_name(name: &str, naming: FieldNaming) -> String {
    match naming {
        FieldNaming::Preserve => name.to_string(),
        FieldNaming::CamelCase => to_camel_case(name),
    }
}

/// Generates a TypeScript interface from a struct definition.
fn generate_interface(s: &StructDef, preserve_docs: bool, field_naming: FieldNaming, out: &mut String) {
    if preserve_docs {
        if let Some(doc) = &s.docs {
            emit_jsdoc(doc, "", out);
        }
    }
    let _ = writeln!(out, "export interface {} {{", s.name);
    for (name, ty) in &s.fields {
        let ts_type = rust_type_to_ts(ty);
        let field_name = transform_field_name(name, field_naming);
        let _ = writeln!(out, "  {field_name}: {ts_type};");
    }
    let _ = writeln!(out, "}}");
}

/// Generates a TypeScript type from an enum definition.
///
/// Supports three variant shapes following serde's default (externally tagged) representation:
/// - Unit variants → string literal union: `"Active" | "Inactive"`
/// - Tuple variants → `{ VariantName: T }` (single field) or `{ VariantName: [A, B] }` (multiple)
/// - Struct variants → `{ VariantName: { field: type } }`
///
/// If all variants are unit, emits a simple string union.
/// Otherwise, emits a discriminated union of object types.
fn generate_enum_type(e: &EnumDef, preserve_docs: bool, field_naming: FieldNaming, out: &mut String) {
    if preserve_docs {
        if let Some(doc) = &e.docs {
            emit_jsdoc(doc, "", out);
        }
    }
    let all_unit = e.variants.iter().all(|v| matches!(v.kind, VariantKind::Unit));

    if all_unit {
        // Simple string literal union
        let variants: Vec<String> = e.variants.iter().map(|v| format!("\"{}\"" , v.name)).collect();
        if variants.is_empty() {
            let _ = writeln!(out, "export type {} = never;", e.name);
        } else {
            let _ = writeln!(out, "export type {} = {};", e.name, variants.join(" | "));
        }
    } else {
        // Tagged union (serde externally tagged default)
        let mut variant_types: Vec<String> = Vec::new();

        for v in &e.variants {
            match &v.kind {
                VariantKind::Unit => {
                    variant_types.push(format!("\"{}\"" , v.name));
                }
                VariantKind::Tuple(types) => {
                    let inner = if types.len() == 1 {
                        rust_type_to_ts(&types[0])
                    } else {
                        let elems: Vec<String> = types.iter().map(rust_type_to_ts).collect();
                        format!("[{}]", elems.join(", "))
                    };
                    variant_types.push(format!("{{ {}: {} }}", v.name, inner));
                }
                VariantKind::Struct(fields) => {
                    let field_strs: Vec<String> = fields
                        .iter()
                        .map(|(name, ty)| {
                            let field_name = transform_field_name(name, field_naming);
                            format!("{}: {}", field_name, rust_type_to_ts(ty))
                        })
                        .collect();
                    variant_types.push(format!("{{ {}: {{ {} }} }}", v.name, field_strs.join("; ")));
                }
            }
        }

        let _ = writeln!(out, "export type {} = {};", e.name, variant_types.join(" | "));
    }
}

/// Generates the `Procedures` type that maps procedure names to their input/output types,
/// grouped by kind (queries / mutations).
fn generate_procedures_type(procedures: &[Procedure], preserve_docs: bool, out: &mut String) {
    let queries: Vec<&Procedure> = procedures
        .iter()
        .filter(|p| p.kind == ProcedureKind::Query)
        .collect();
    let mutations: Vec<&Procedure> = procedures
        .iter()
        .filter(|p| p.kind == ProcedureKind::Mutation)
        .collect();

    let _ = writeln!(out, "export type Procedures = {{");

    // Queries
    let _ = writeln!(out, "  queries: {{");
    for proc in &queries {
        if preserve_docs {
            if let Some(doc) = &proc.docs {
                emit_jsdoc(doc, "    ", out);
            }
        }
        let input = proc
            .input
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let output = proc
            .output
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let _ = writeln!(out, "    {}: {{ input: {input}; output: {output} }};", proc.name);
    }
    let _ = writeln!(out, "  }};");

    // Mutations
    let _ = writeln!(out, "  mutations: {{");
    for proc in &mutations {
        if preserve_docs {
            if let Some(doc) = &proc.docs {
                emit_jsdoc(doc, "    ", out);
            }
        }
        let input = proc
            .input
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let output = proc
            .output
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let _ = writeln!(out, "    {}: {{ input: {input}; output: {output} }};", proc.name);
    }
    let _ = writeln!(out, "  }};");

    let _ = writeln!(out, "}};");
}

/// Generates the complete `rpc-types.ts` file content from a manifest.
///
/// The output includes:
/// 1. Auto-generation header
/// 2. TypeScript interfaces for all referenced structs
/// 3. The `Procedures` type mapping
pub fn generate_types_file(manifest: &Manifest, preserve_docs: bool, field_naming: FieldNaming) -> String {
    let mut out = String::with_capacity(1024);

    // Header
    out.push_str(GENERATED_HEADER);
    out.push('\n');

    // Emit all structs discovered in the scanned files.
    for s in &manifest.structs {
        generate_interface(s, preserve_docs, field_naming, &mut out);
        out.push('\n');
    }

    // Emit all enums discovered in the scanned files.
    for e in &manifest.enums {
        generate_enum_type(e, preserve_docs, field_naming, &mut out);
        out.push('\n');
    }

    // Generate the Procedures type
    generate_procedures_type(&manifest.procedures, preserve_docs, &mut out);

    out
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::FieldNaming;
    use crate::model::*;
    use std::path::PathBuf;

    // --- rust_type_to_ts ---

    #[test]
    fn maps_string_types() {
        assert_eq!(rust_type_to_ts(&RustType::simple("String")), "string");
        assert_eq!(rust_type_to_ts(&RustType::simple("str")), "string");
        assert_eq!(rust_type_to_ts(&RustType::simple("char")), "string");
    }

    #[test]
    fn maps_numeric_types() {
        for name in ["i8", "i16", "i32", "i64", "u8", "u16", "u32", "u64", "f32", "f64", "usize", "isize"] {
            assert_eq!(rust_type_to_ts(&RustType::simple(name)), "number", "failed for {name}");
        }
    }

    #[test]
    fn maps_bool() {
        assert_eq!(rust_type_to_ts(&RustType::simple("bool")), "boolean");
    }

    #[test]
    fn maps_unit() {
        assert_eq!(rust_type_to_ts(&RustType::simple("()")), "void");
    }

    #[test]
    fn maps_vec() {
        let ty = RustType::with_generics("Vec", vec![RustType::simple("String")]);
        assert_eq!(rust_type_to_ts(&ty), "string[]");
    }

    #[test]
    fn maps_vec_of_option() {
        let inner = RustType::with_generics("Option", vec![RustType::simple("i32")]);
        let ty = RustType::with_generics("Vec", vec![inner]);
        assert_eq!(rust_type_to_ts(&ty), "(number | null)[]");
    }

    #[test]
    fn maps_option() {
        let ty = RustType::with_generics("Option", vec![RustType::simple("String")]);
        assert_eq!(rust_type_to_ts(&ty), "string | null");
    }

    #[test]
    fn maps_hashmap() {
        let ty = RustType::with_generics(
            "HashMap",
            vec![RustType::simple("String"), RustType::simple("i32")],
        );
        assert_eq!(rust_type_to_ts(&ty), "Record<string, number>");
    }

    #[test]
    fn maps_btreemap() {
        let ty = RustType::with_generics(
            "BTreeMap",
            vec![RustType::simple("String"), RustType::simple("bool")],
        );
        assert_eq!(rust_type_to_ts(&ty), "Record<string, boolean>");
    }

    #[test]
    fn maps_tuple() {
        let ty = RustType::with_generics(
            "tuple",
            vec![RustType::simple("String"), RustType::simple("i32")],
        );
        assert_eq!(rust_type_to_ts(&ty), "[string, number]");
    }

    #[test]
    fn maps_custom_struct() {
        assert_eq!(rust_type_to_ts(&RustType::simple("TimeResponse")), "TimeResponse");
    }

    #[test]
    fn maps_nested_generics() {
        // Option<Vec<String>> → string[] | null
        let ty = RustType::with_generics(
            "Option",
            vec![RustType::with_generics("Vec", vec![RustType::simple("String")])],
        );
        assert_eq!(rust_type_to_ts(&ty), "string[] | null");
    }

    // --- generate_types_file ---

    fn make_test_manifest() -> Manifest {
        Manifest {
            procedures: vec![
                Procedure {
                    name: "hello".to_string(),
                    kind: ProcedureKind::Query,
                    input: Some(RustType::simple("String")),
                    output: Some(RustType::simple("String")),
                    source_file: PathBuf::from("api/hello.rs"),
                    docs: None,
                },
                Procedure {
                    name: "time".to_string(),
                    kind: ProcedureKind::Query,
                    input: None,
                    output: Some(RustType::simple("TimeResponse")),
                    source_file: PathBuf::from("api/time.rs"),
                    docs: None,
                },
                Procedure {
                    name: "create_item".to_string(),
                    kind: ProcedureKind::Mutation,
                    input: Some(RustType::simple("CreateInput")),
                    output: Some(RustType::simple("Item")),
                    source_file: PathBuf::from("api/create_item.rs"),
                    docs: None,
                },
            ],
            structs: vec![
                StructDef {
                    name: "TimeResponse".to_string(),
                    fields: vec![
                        ("timestamp".to_string(), RustType::simple("u64")),
                        ("message".to_string(), RustType::simple("String")),
                    ],
                    source_file: PathBuf::from("api/time.rs"),
                    docs: None,
                },
                StructDef {
                    name: "CreateInput".to_string(),
                    fields: vec![
                        ("title".to_string(), RustType::simple("String")),
                        ("count".to_string(), RustType::simple("i32")),
                    ],
                    source_file: PathBuf::from("api/create_item.rs"),
                    docs: None,
                },
                StructDef {
                    name: "Item".to_string(),
                    fields: vec![
                        ("id".to_string(), RustType::simple("u64")),
                        ("title".to_string(), RustType::simple("String")),
                        ("tags".to_string(), RustType::with_generics("Vec", vec![RustType::simple("String")])),
                    ],
                    source_file: PathBuf::from("api/create_item.rs"),
                    docs: None,
                },
            ],
            enums: vec![],
        }
    }

    #[test]
    fn generates_complete_types_file() {
        let manifest = make_test_manifest();
        let output = generate_types_file(&manifest, false, FieldNaming::Preserve);

        // Header present
        assert!(output.starts_with("// This file is auto-generated"));

        // Interfaces generated
        assert!(output.contains("export interface TimeResponse {"));
        assert!(output.contains("  timestamp: number;"));
        assert!(output.contains("  message: string;"));

        assert!(output.contains("export interface CreateInput {"));
        assert!(output.contains("  title: string;"));
        assert!(output.contains("  count: number;"));

        assert!(output.contains("export interface Item {"));
        assert!(output.contains("  id: number;"));
        assert!(output.contains("  tags: string[];"));

        // Procedures type
        assert!(output.contains("export type Procedures = {"));
        assert!(output.contains("  queries: {"));
        assert!(output.contains("    hello: { input: string; output: string };"));
        assert!(output.contains("    time: { input: void; output: TimeResponse };"));
        assert!(output.contains("  mutations: {"));
        assert!(output.contains("    create_item: { input: CreateInput; output: Item };"));
    }

    #[test]
    fn generates_empty_manifest() {
        let manifest = Manifest::default();
        let output = generate_types_file(&manifest, false, FieldNaming::Preserve);

        assert!(output.contains("queries: {"));
        assert!(output.contains("mutations: {"));
        // No interfaces
        assert!(!output.contains("export interface"));
    }

    #[test]
    fn generates_queries_only() {
        let manifest = Manifest {
            procedures: vec![Procedure {
                name: "ping".to_string(),
                kind: ProcedureKind::Query,
                input: None,
                output: Some(RustType::simple("String")),
                source_file: PathBuf::from("api/ping.rs"),
                docs: None,
            }],
            structs: vec![],
            enums: vec![],
        };
        let output = generate_types_file(&manifest, false, FieldNaming::Preserve);

        assert!(output.contains("    ping: { input: void; output: string };"));
        assert!(!output.contains("export interface"));
    }

    #[test]
    fn generates_complex_nested_types() {
        let manifest = Manifest {
            procedures: vec![Procedure {
                name: "search".to_string(),
                kind: ProcedureKind::Query,
                input: Some(RustType::simple("String")),
                output: Some(RustType::with_generics(
                    "Vec",
                    vec![RustType::with_generics(
                        "Option",
                        vec![RustType::simple("Item")],
                    )],
                )),
                source_file: PathBuf::from("api/search.rs"),
                docs: None,
            }],
            structs: vec![],
            enums: vec![],
        };
        let output = generate_types_file(&manifest, false, FieldNaming::Preserve);
        assert!(output.contains("    search: { input: string; output: (Item | null)[] };"));
    }

    // --- enum codegen ---

    #[test]
    fn generates_unit_enum_as_string_union() {
        let manifest = Manifest {
            procedures: vec![],
            structs: vec![],
            enums: vec![EnumDef {
                name: "Status".to_string(),
                variants: vec![
                    EnumVariant { name: "Active".to_string(), kind: VariantKind::Unit },
                    EnumVariant { name: "Inactive".to_string(), kind: VariantKind::Unit },
                    EnumVariant { name: "Banned".to_string(), kind: VariantKind::Unit },
                ],
                source_file: PathBuf::from("api/test.rs"),
                docs: None,
            }],
        };
        let output = generate_types_file(&manifest, false, FieldNaming::Preserve);
        assert!(output.contains("export type Status = \"Active\" | \"Inactive\" | \"Banned\";"));
    }

    #[test]
    fn generates_tuple_enum_as_tagged_union() {
        let manifest = Manifest {
            procedures: vec![],
            structs: vec![],
            enums: vec![EnumDef {
                name: "Response".to_string(),
                variants: vec![
                    EnumVariant {
                        name: "Ok".to_string(),
                        kind: VariantKind::Tuple(vec![RustType::simple("String")]),
                    },
                    EnumVariant {
                        name: "Error".to_string(),
                        kind: VariantKind::Tuple(vec![RustType::simple("i32")]),
                    },
                ],
                source_file: PathBuf::from("api/test.rs"),
                docs: None,
            }],
        };
        let output = generate_types_file(&manifest, false, FieldNaming::Preserve);
        assert!(output.contains("export type Response = { Ok: string } | { Error: number };"));
    }

    #[test]
    fn generates_struct_enum_as_tagged_union() {
        let manifest = Manifest {
            procedures: vec![],
            structs: vec![],
            enums: vec![EnumDef {
                name: "Event".to_string(),
                variants: vec![
                    EnumVariant {
                        name: "Click".to_string(),
                        kind: VariantKind::Struct(vec![
                            ("x".to_string(), RustType::simple("i32")),
                            ("y".to_string(), RustType::simple("i32")),
                        ]),
                    },
                ],
                source_file: PathBuf::from("api/test.rs"),
                docs: None,
            }],
        };
        let output = generate_types_file(&manifest, false, FieldNaming::Preserve);
        assert!(output.contains("export type Event = { Click: { x: number; y: number } };"));
    }

    #[test]
    fn generates_mixed_enum() {
        let manifest = Manifest {
            procedures: vec![],
            structs: vec![],
            enums: vec![EnumDef {
                name: "Shape".to_string(),
                variants: vec![
                    EnumVariant {
                        name: "Circle".to_string(),
                        kind: VariantKind::Tuple(vec![RustType::simple("f64")]),
                    },
                    EnumVariant {
                        name: "Rect".to_string(),
                        kind: VariantKind::Struct(vec![
                            ("w".to_string(), RustType::simple("f64")),
                            ("h".to_string(), RustType::simple("f64")),
                        ]),
                    },
                    EnumVariant { name: "Unknown".to_string(), kind: VariantKind::Unit },
                ],
                source_file: PathBuf::from("api/test.rs"),
                docs: None,
            }],
        };
        let output = generate_types_file(&manifest, false, FieldNaming::Preserve);
        assert!(output.contains("export type Shape = { Circle: number } | { Rect: { w: number; h: number } } | \"Unknown\";"));
    }

    #[test]
    fn generates_empty_enum_as_never() {
        let manifest = Manifest {
            procedures: vec![],
            structs: vec![],
            enums: vec![EnumDef {
                name: "Empty".to_string(),
                variants: vec![],
                source_file: PathBuf::from("api/test.rs"),
                docs: None,
            }],
        };
        let output = generate_types_file(&manifest, false, FieldNaming::Preserve);
        assert!(output.contains("export type Empty = never;"));
    }

    #[test]
    fn generates_multi_field_tuple_variant() {
        let manifest = Manifest {
            procedures: vec![],
            structs: vec![],
            enums: vec![EnumDef {
                name: "Pair".to_string(),
                variants: vec![
                    EnumVariant {
                        name: "Both".to_string(),
                        kind: VariantKind::Tuple(vec![
                            RustType::simple("String"),
                            RustType::simple("i32"),
                        ]),
                    },
                ],
                source_file: PathBuf::from("api/test.rs"),
                docs: None,
            }],
        };
        let output = generate_types_file(&manifest, false, FieldNaming::Preserve);
        assert!(output.contains("export type Pair = { Both: [string, number] };"));
    }

    // --- JSDoc tests ---

    #[test]
    fn test_jsdoc_on_struct() {
        let manifest = Manifest {
            procedures: vec![],
            structs: vec![StructDef {
                name: "Foo".to_string(),
                fields: vec![("x".to_string(), RustType::simple("i32"))],
                source_file: PathBuf::from("api/test.rs"),
                docs: Some("A foo struct.".to_string()),
            }],
            enums: vec![],
        };
        let output = generate_types_file(&manifest, true, FieldNaming::Preserve);
        assert!(output.contains("/** A foo struct. */\nexport interface Foo {"));
    }

    #[test]
    fn test_jsdoc_on_struct_multiline() {
        let manifest = Manifest {
            procedures: vec![],
            structs: vec![StructDef {
                name: "Bar".to_string(),
                fields: vec![],
                source_file: PathBuf::from("api/test.rs"),
                docs: Some("Line one.\nLine two.".to_string()),
            }],
            enums: vec![],
        };
        let output = generate_types_file(&manifest, true, FieldNaming::Preserve);
        assert!(output.contains("/**\n * Line one.\n * Line two.\n */\nexport interface Bar {"));
    }

    #[test]
    fn test_jsdoc_on_enum() {
        let manifest = Manifest {
            procedures: vec![],
            structs: vec![],
            enums: vec![EnumDef {
                name: "Status".to_string(),
                variants: vec![
                    EnumVariant { name: "Active".to_string(), kind: VariantKind::Unit },
                ],
                source_file: PathBuf::from("api/test.rs"),
                docs: Some("Entity status.".to_string()),
            }],
        };
        let output = generate_types_file(&manifest, true, FieldNaming::Preserve);
        assert!(output.contains("/** Entity status. */\nexport type Status ="));
    }

    #[test]
    fn test_jsdoc_on_procedure() {
        let manifest = Manifest {
            procedures: vec![Procedure {
                name: "hello".to_string(),
                kind: ProcedureKind::Query,
                input: Some(RustType::simple("String")),
                output: Some(RustType::simple("String")),
                source_file: PathBuf::from("api/hello.rs"),
                docs: Some("Say hello.".to_string()),
            }],
            structs: vec![],
            enums: vec![],
        };
        let output = generate_types_file(&manifest, true, FieldNaming::Preserve);
        assert!(output.contains("    /** Say hello. */\n    hello: { input: string; output: string };"));
    }

    #[test]
    fn test_no_jsdoc_when_disabled() {
        let manifest = Manifest {
            procedures: vec![Procedure {
                name: "hello".to_string(),
                kind: ProcedureKind::Query,
                input: Some(RustType::simple("String")),
                output: Some(RustType::simple("String")),
                source_file: PathBuf::from("api/hello.rs"),
                docs: Some("Say hello.".to_string()),
            }],
            structs: vec![StructDef {
                name: "Foo".to_string(),
                fields: vec![],
                source_file: PathBuf::from("api/test.rs"),
                docs: Some("A foo.".to_string()),
            }],
            enums: vec![],
        };
        let output = generate_types_file(&manifest, false, FieldNaming::Preserve);
        assert!(!output.contains("/**"));
    }

    // --- to_camel_case ---

    #[test]
    fn test_to_camel_case() {
        assert_eq!(to_camel_case("uptime_secs"), "uptimeSecs");
        assert_eq!(to_camel_case("user_id"), "userId");
        assert_eq!(to_camel_case("message"), "message");
        assert_eq!(to_camel_case("created_at_ms"), "createdAtMs");
    }

    // --- camelCase field naming ---

    #[test]
    fn test_camel_case_fields() {
        let manifest = Manifest {
            procedures: vec![],
            structs: vec![StructDef {
                name: "ServerInfo".to_string(),
                fields: vec![
                    ("uptime_secs".to_string(), RustType::simple("u64")),
                    ("user_id".to_string(), RustType::simple("String")),
                    ("message".to_string(), RustType::simple("String")),
                ],
                source_file: PathBuf::from("api/test.rs"),
                docs: None,
            }],
            enums: vec![],
        };
        let output = generate_types_file(&manifest, false, FieldNaming::CamelCase);
        assert!(output.contains("  uptimeSecs: number;"));
        assert!(output.contains("  userId: string;"));
        assert!(output.contains("  message: string;"));
    }

    #[test]
    fn test_camel_case_enum_struct_variant() {
        let manifest = Manifest {
            procedures: vec![],
            structs: vec![],
            enums: vec![EnumDef {
                name: "Event".to_string(),
                variants: vec![EnumVariant {
                    name: "Click".to_string(),
                    kind: VariantKind::Struct(vec![
                        ("page_x".to_string(), RustType::simple("i32")),
                        ("page_y".to_string(), RustType::simple("i32")),
                    ]),
                }],
                source_file: PathBuf::from("api/test.rs"),
                docs: None,
            }],
        };
        let output = generate_types_file(&manifest, false, FieldNaming::CamelCase);
        assert!(output.contains("{ Click: { pageX: number; pageY: number } }"));
    }
}
