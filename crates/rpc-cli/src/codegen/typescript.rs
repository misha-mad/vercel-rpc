use crate::config::FieldNaming;
use crate::model::{
    EnumDef, EnumTagging, EnumVariant, FieldDef, Manifest, Procedure, ProcedureKind, RenameRule,
    RustType, StructDef, VariantKind,
};

// Header comment included at the top of every generated file.
const GENERATED_HEADER: &str = "\
// This file is auto-generated by vercel-rpc-cli. Do not edit manually.
// Re-run `rpc generate` or use `rpc watch` to regenerate.
";

/// Converts a `RustType` into its TypeScript equivalent.
///
/// Mapping rules:
/// - Rust primitives (`String`, `str`, `char`) → `string`
/// - Numeric types (`i8`..`i128`, `u8`..`u128`, `f32`, `f64`, `isize`, `usize`) → `number`
/// - `bool` → `boolean`
/// - `()` → `void`
/// - `Vec<T>`, `Array<T>`, `HashSet<T>`, `BTreeSet<T>` → `T[]`
/// - `Option<T>` → `T | null`
/// - `HashMap<K, V>`, `BTreeMap<K, V>` → `Record<K, V>`
/// - `Box<T>`, `Arc<T>`, `Rc<T>`, `Cow<T>` → `T` (transparent wrappers)
/// - `tuple(A, B, ...)` → `[A, B, ...]`
/// - Everything else (user-defined structs) → kept as-is
pub fn rust_type_to_ts(ty: &RustType) -> String {
    match ty.name.as_str() {
        // Unit type
        "()" => "void".to_string(),

        // String types
        "String" | "str" | "char" | "&str" => "string".to_string(),

        // Boolean
        "bool" => "boolean".to_string(),

        // Numeric types
        "i8" | "i16" | "i32" | "i64" | "i128" | "u8" | "u16" | "u32" | "u64" | "u128" | "f32"
        | "f64" | "isize" | "usize" => "number".to_string(),

        // Vec / Array / Set types → T[]
        "Vec" | "Array" | "HashSet" | "BTreeSet" => {
            let inner = ty
                .generics
                .first()
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "unknown".to_string());
            // Wrap union types in parens for correct precedence: `(A | B)[]`
            if inner.contains(" | ") {
                format!("({inner})[]")
            } else {
                format!("{inner}[]")
            }
        }

        // Option<T> → T | null
        "Option" => {
            let inner = ty
                .generics
                .first()
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "unknown".to_string());
            format!("{inner} | null")
        }

        // HashMap / BTreeMap → Record<K, V>
        "HashMap" | "BTreeMap" => {
            let key = ty
                .generics
                .first()
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "string".to_string());
            let value = ty
                .generics
                .get(1)
                .map(rust_type_to_ts)
                .unwrap_or_else(|| "unknown".to_string());
            format!("Record<{key}, {value}>")
        }

        // Smart pointers / wrappers → unwrap to inner type
        "Box" | "Arc" | "Rc" | "Cow" => ty
            .generics
            .first()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "unknown".to_string()),

        // Tuple → [A, B, ...]
        "tuple" => {
            let elems: Vec<String> = ty.generics.iter().map(rust_type_to_ts).collect();
            format!("[{}]", elems.join(", "))
        }

        // User-defined types or unknown — pass through as-is
        other => other.to_string(),
    }
}

/// Emits a JSDoc comment block from a doc string.
pub fn emit_jsdoc(doc: &str, indent: &str, out: &mut String) {
    if !doc.contains('\n') {
        emit!(out, "{indent}/** {doc} */");
    } else {
        emit!(out, "{indent}/**");
        for line in doc.lines() {
            emit!(out, "{indent} * {line}");
        }
        emit!(out, "{indent} */");
    }
}

/// Converts a snake_case string to camelCase.
pub fn to_camel_case(s: &str) -> String {
    let mut segments = s.split('_');
    let mut result = segments
        .next()
        .expect("split always yields at least one element")
        .to_lowercase();
    for segment in segments {
        let mut chars = segment.chars();
        if let Some(first) = chars.next() {
            result.extend(first.to_uppercase());
            result.push_str(&chars.as_str().to_lowercase());
        }
    }
    result
}

/// Transforms a field name according to the naming strategy.
fn transform_field_name(name: &str, naming: FieldNaming) -> String {
    match naming {
        FieldNaming::Preserve => name.to_string(),
        FieldNaming::CamelCase => to_camel_case(name),
    }
}

/// Resolves the final output name for a struct/variant field.
///
/// Priority: field `rename` > container `rename_all` > config `field_naming` > original name.
fn resolve_field_name(
    field: &FieldDef,
    container_rename_all: Option<RenameRule>,
    config_naming: FieldNaming,
) -> String {
    if let Some(rename) = &field.rename {
        return rename.clone();
    }
    if let Some(rule) = container_rename_all {
        return rule.apply(&field.name);
    }
    transform_field_name(&field.name, config_naming)
}

/// Resolves the final output name for an enum variant.
///
/// Priority: variant `rename` > container `rename_all` > original name.
fn resolve_variant_name(variant: &EnumVariant, container_rename_all: Option<RenameRule>) -> String {
    if let Some(rename) = &variant.rename {
        return rename.clone();
    }
    if let Some(rule) = container_rename_all {
        return rule.apply(&variant.name);
    }
    variant.name.clone()
}

/// Returns the inner type of `Option<T>`, or `None` if not an Option.
fn option_inner_type(ty: &RustType) -> Option<&RustType> {
    if ty.name == "Option" {
        ty.generics.first()
    } else {
        None
    }
}

/// Renders a single struct/variant field as `name: T` or `name?: T | null`.
///
/// When a field has `#[serde(default)]` and is `Option<T>`, it becomes optional
/// (`name?: T | null`). Otherwise it renders as a required field (`name: T`).
fn render_field_str(
    field: &FieldDef,
    container_rename_all: Option<RenameRule>,
    config_naming: FieldNaming,
) -> String {
    let name = resolve_field_name(field, container_rename_all, config_naming);
    if field.has_default
        && let Some(inner) = option_inner_type(&field.ty)
    {
        format!("{}?: {} | null", name, rust_type_to_ts(inner))
    } else {
        format!("{}: {}", name, rust_type_to_ts(&field.ty))
    }
}

/// Generates a TypeScript interface from a struct definition.
fn generate_interface(
    s: &StructDef,
    preserve_docs: bool,
    field_naming: FieldNaming,
    out: &mut String,
) {
    if preserve_docs && let Some(doc) = &s.docs {
        emit_jsdoc(doc, "", out);
    }
    emit!(out, "export interface {} {{", s.name);
    for field in &s.fields {
        if field.skip {
            continue;
        }
        let rendered = render_field_str(field, s.rename_all, field_naming);
        emit!(out, "  {rendered};");
    }
    emit!(out, "}}");
}

/// Generates a TypeScript type from an enum definition.
///
/// Dispatches to the appropriate strategy based on `e.tagging`:
/// - `External` (default): serde's externally tagged representation
/// - `Internal { tag }`: internally tagged (`#[serde(tag = "...")]`)
/// - `Adjacent { tag, content }`: adjacently tagged (`#[serde(tag = "...", content = "...")]`)
/// - `Untagged`: no tag wrapper (`#[serde(untagged)]`)
fn generate_enum_type(
    e: &EnumDef,
    preserve_docs: bool,
    field_naming: FieldNaming,
    out: &mut String,
) {
    if preserve_docs && let Some(doc) = &e.docs {
        emit_jsdoc(doc, "", out);
    }

    match &e.tagging {
        EnumTagging::External => generate_enum_external(e, field_naming, out),
        EnumTagging::Internal { tag } => generate_enum_internal(e, tag, field_naming, out),
        EnumTagging::Adjacent { tag, content } => {
            generate_enum_adjacent(e, tag, content, field_naming, out);
        }
        EnumTagging::Untagged => generate_enum_untagged(e, field_naming, out),
    }
}

/// Externally tagged (serde default): `{ "Variant": data }` or string literal for unit variants.
fn generate_enum_external(e: &EnumDef, field_naming: FieldNaming, out: &mut String) {
    let all_unit = e
        .variants
        .iter()
        .all(|v| matches!(v.kind, VariantKind::Unit));

    if all_unit {
        let variants: Vec<String> = e
            .variants
            .iter()
            .map(|v| {
                let name = resolve_variant_name(v, e.rename_all);
                format!("\"{name}\"")
            })
            .collect();
        if variants.is_empty() {
            emit!(out, "export type {} = never;", e.name);
        } else {
            emit!(out, "export type {} = {};", e.name, variants.join(" | "));
        }
    } else {
        let mut variant_types: Vec<String> = Vec::new();

        for v in &e.variants {
            let variant_name = resolve_variant_name(v, e.rename_all);
            match &v.kind {
                VariantKind::Unit => {
                    variant_types.push(format!("\"{variant_name}\""));
                }
                VariantKind::Tuple(types) => {
                    let inner = if types.len() == 1 {
                        rust_type_to_ts(&types[0])
                    } else {
                        let elems: Vec<String> = types.iter().map(rust_type_to_ts).collect();
                        format!("[{}]", elems.join(", "))
                    };
                    variant_types.push(format!("{{ {variant_name}: {inner} }}"));
                }
                VariantKind::Struct(fields) => {
                    let field_strs: Vec<String> = fields
                        .iter()
                        .filter(|f| !f.skip)
                        .map(|field| render_field_str(field, e.rename_all, field_naming))
                        .collect();
                    variant_types.push(format!(
                        "{{ {variant_name}: {{ {} }} }}",
                        field_strs.join("; ")
                    ));
                }
            }
        }

        emit!(
            out,
            "export type {} = {};",
            e.name,
            variant_types.join(" | ")
        );
    }
}

/// Internally tagged: `{ "tag": "Variant", ...fields }`.
///
/// - Unit → `{ tag: "Name" }`
/// - Struct → `{ tag: "Name"; field: T; ... }`
/// - Tuple(1) → `{ tag: "Name" } & InnerType` (newtype wrapping struct)
/// - Tuple(n>1) → skipped (serde rejects multi-field tuples in internally tagged)
fn generate_enum_internal(e: &EnumDef, tag: &str, field_naming: FieldNaming, out: &mut String) {
    if e.variants.is_empty() {
        emit!(out, "export type {} = never;", e.name);
        return;
    }

    let mut variant_types: Vec<String> = Vec::new();

    for v in &e.variants {
        let variant_name = resolve_variant_name(v, e.rename_all);
        match &v.kind {
            VariantKind::Unit => {
                variant_types.push(format!("{{ {tag}: \"{variant_name}\" }}"));
            }
            VariantKind::Struct(fields) => {
                let field_strs: Vec<String> = fields
                    .iter()
                    .filter(|f| !f.skip)
                    .map(|field| render_field_str(field, e.rename_all, field_naming))
                    .collect();
                let mut parts = vec![format!("{tag}: \"{variant_name}\"")];
                parts.extend(field_strs);
                variant_types.push(format!("{{ {} }}", parts.join("; ")));
            }
            VariantKind::Tuple(types) => {
                if types.len() == 1 {
                    let inner = rust_type_to_ts(&types[0]);
                    variant_types.push(format!("{{ {tag}: \"{variant_name}\" }} & {inner}"));
                }
                // Multi-field tuples are rejected by serde for internal tagging — skip
            }
        }
    }

    if variant_types.is_empty() {
        emit!(out, "export type {} = never;", e.name);
    } else {
        emit!(
            out,
            "export type {} = {};",
            e.name,
            variant_types.join(" | ")
        );
    }
}

/// Adjacently tagged: `{ "tag": "Variant", "content": data }`.
///
/// - Unit → `{ tag: "Name" }` (no content key)
/// - Tuple(1) → `{ tag: "Name"; content: T }`
/// - Tuple(n) → `{ tag: "Name"; content: [A, B, ...] }`
/// - Struct → `{ tag: "Name"; content: { field: T; ... } }`
fn generate_enum_adjacent(
    e: &EnumDef,
    tag: &str,
    content: &str,
    field_naming: FieldNaming,
    out: &mut String,
) {
    if e.variants.is_empty() {
        emit!(out, "export type {} = never;", e.name);
        return;
    }

    let mut variant_types: Vec<String> = Vec::new();

    for v in &e.variants {
        let variant_name = resolve_variant_name(v, e.rename_all);
        match &v.kind {
            VariantKind::Unit => {
                variant_types.push(format!("{{ {tag}: \"{variant_name}\" }}"));
            }
            VariantKind::Tuple(types) => {
                let inner = if types.len() == 1 {
                    rust_type_to_ts(&types[0])
                } else {
                    let elems: Vec<String> = types.iter().map(rust_type_to_ts).collect();
                    format!("[{}]", elems.join(", "))
                };
                variant_types.push(format!(
                    "{{ {tag}: \"{variant_name}\"; {content}: {inner} }}"
                ));
            }
            VariantKind::Struct(fields) => {
                let field_strs: Vec<String> = fields
                    .iter()
                    .filter(|f| !f.skip)
                    .map(|field| render_field_str(field, e.rename_all, field_naming))
                    .collect();
                variant_types.push(format!(
                    "{{ {tag}: \"{variant_name}\"; {content}: {{ {} }} }}",
                    field_strs.join("; ")
                ));
            }
        }
    }

    emit!(
        out,
        "export type {} = {};",
        e.name,
        variant_types.join(" | ")
    );
}

/// Untagged: no wrapper, just the data.
///
/// - Unit → `null`
/// - Tuple(1) → `T`
/// - Tuple(n) → `[A, B, ...]`
/// - Struct → `{ field: T; ... }`
/// - Empty enum → `never`
fn generate_enum_untagged(e: &EnumDef, field_naming: FieldNaming, out: &mut String) {
    if e.variants.is_empty() {
        emit!(out, "export type {} = never;", e.name);
        return;
    }

    let mut variant_types: Vec<String> = Vec::new();

    for v in &e.variants {
        match &v.kind {
            VariantKind::Unit => {
                variant_types.push("null".to_string());
            }
            VariantKind::Tuple(types) => {
                if types.len() == 1 {
                    variant_types.push(rust_type_to_ts(&types[0]));
                } else {
                    let elems: Vec<String> = types.iter().map(rust_type_to_ts).collect();
                    variant_types.push(format!("[{}]", elems.join(", ")));
                }
            }
            VariantKind::Struct(fields) => {
                let field_strs: Vec<String> = fields
                    .iter()
                    .filter(|f| !f.skip)
                    .map(|field| render_field_str(field, e.rename_all, field_naming))
                    .collect();
                variant_types.push(format!("{{ {} }}", field_strs.join("; ")));
            }
        }
    }

    emit!(
        out,
        "export type {} = {};",
        e.name,
        variant_types.join(" | ")
    );
}

/// Generates the `Procedures` type that maps procedure names to their input/output types,
/// grouped by kind (queries / mutations).
fn generate_procedures_type(procedures: &[Procedure], preserve_docs: bool, out: &mut String) {
    let (queries, mutations): (Vec<_>, Vec<_>) = procedures
        .iter()
        .partition(|p| p.kind == ProcedureKind::Query);

    emit!(out, "export type Procedures = {{");

    // Queries
    emit!(out, "  queries: {{");
    for proc in &queries {
        if preserve_docs && let Some(doc) = &proc.docs {
            emit_jsdoc(doc, "    ", out);
        }
        let input = proc
            .input
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let output = proc
            .output
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        emit!(
            out,
            "    {}: {{ input: {input}; output: {output} }};",
            proc.name
        );
    }
    emit!(out, "  }};");

    // Mutations
    emit!(out, "  mutations: {{");
    for proc in &mutations {
        if preserve_docs && let Some(doc) = &proc.docs {
            emit_jsdoc(doc, "    ", out);
        }
        let input = proc
            .input
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        let output = proc
            .output
            .as_ref()
            .map(rust_type_to_ts)
            .unwrap_or_else(|| "void".to_string());
        emit!(
            out,
            "    {}: {{ input: {input}; output: {output} }};",
            proc.name
        );
    }
    emit!(out, "  }};");

    emit!(out, "}};");
}

/// Generates the complete `rpc-types.ts` file content from a manifest.
///
/// The output includes:
/// 1. Auto-generation header
/// 2. TypeScript interfaces for all referenced structs
/// 3. The `Procedures` type mapping
pub fn generate_types_file(
    manifest: &Manifest,
    preserve_docs: bool,
    field_naming: FieldNaming,
) -> String {
    let mut out = String::with_capacity(1024);

    // Header
    out.push_str(GENERATED_HEADER);
    out.push('\n');

    // Emit all structs discovered in the scanned files.
    for s in &manifest.structs {
        generate_interface(s, preserve_docs, field_naming, &mut out);
        out.push('\n');
    }

    // Emit all enums discovered in the scanned files.
    for e in &manifest.enums {
        generate_enum_type(e, preserve_docs, field_naming, &mut out);
        out.push('\n');
    }

    // Generate the Procedures type
    generate_procedures_type(&manifest.procedures, preserve_docs, &mut out);

    out
}
