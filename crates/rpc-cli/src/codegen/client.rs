use std::fmt::Write;

use crate::model::{Manifest, Procedure, ProcedureKind};
use super::typescript::{emit_jsdoc, rust_type_to_ts};

// Header comment included at the top of every generated client file.
const GENERATED_HEADER: &str = "\
// This file is auto-generated by vercel-rpc-cli. Do not edit manually.
// Re-run `rpc generate` or use `rpc watch` to regenerate.
";

/// Standard RPC error class with status code and structured error data.
const ERROR_CLASS: &str = r#"export class RpcError extends Error {
  readonly status: number;
  readonly data: unknown;

  constructor(status: number, message: string, data?: unknown) {
    super(message);
    this.name = "RpcError";
    this.status = status;
    this.data = data;
  }
}"#;

/// Internal fetch helper shared by query and mutate methods.
const FETCH_HELPER: &str = r#"async function rpcFetch(
  baseUrl: string,
  method: "GET" | "POST",
  procedure: string,
  input?: unknown,
): Promise<unknown> {
  let url = `${baseUrl}/${procedure}`;
  const init: RequestInit = { method, headers: {} };

  if (method === "GET" && input !== undefined) {
    url += `?input=${encodeURIComponent(JSON.stringify(input))}`;
  } else if (method === "POST" && input !== undefined) {
    init.body = JSON.stringify(input);
    (init.headers as Record<string, string>)["Content-Type"] = "application/json";
  }

  const res = await fetch(url, init);

  if (!res.ok) {
    let data: unknown;
    try {
      data = await res.json();
    } catch {
      data = await res.text().catch(() => null);
    }
    throw new RpcError(
      res.status,
      `RPC error on "${procedure}": ${res.status} ${res.statusText}`,
      data,
    );
  }

  const json = await res.json();
  return json?.result?.data ?? json;
}"#;

/// Generates the complete `rpc-client.ts` file content from a manifest.
///
/// The output includes:
/// 1. Auto-generation header
/// 2. Re-export of `Procedures` type from the types file
/// 3. `RpcError` class for structured error handling
/// 4. Internal `rpcFetch` helper
/// 5. `createRpcClient` factory function with fully typed `query` / `mutate` methods
pub fn generate_client_file(manifest: &Manifest, types_import_path: &str, preserve_docs: bool) -> String {
    let mut out = String::with_capacity(2048);

    // Header
    out.push_str(GENERATED_HEADER);
    out.push('\n');

    // Collect all user-defined type names (structs + enums) for import
    let type_names: Vec<&str> = manifest
        .structs
        .iter()
        .map(|s| s.name.as_str())
        .chain(manifest.enums.iter().map(|e| e.name.as_str()))
        .collect();

    // Import Procedures type (and any referenced types) from the types file
    if type_names.is_empty() {
        let _ = writeln!(out, "import type {{ Procedures }} from \"{types_import_path}\";\n");
        let _ = writeln!(out, "export type {{ Procedures }};\n");
    } else {
        let types_csv = type_names.join(", ");
        let _ = writeln!(out, "import type {{ Procedures, {types_csv} }} from \"{types_import_path}\";\n");
        let _ = writeln!(out, "export type {{ Procedures, {types_csv} }};\n");
    }

    // Error class
    let _ = writeln!(out, "{ERROR_CLASS}\n");

    // Internal fetch helper
    let _ = writeln!(out, "{FETCH_HELPER}\n");

    // Type helpers for ergonomic API
    generate_type_helpers(&mut out);
    out.push('\n');

    // Client factory
    generate_client_factory(manifest, preserve_docs, &mut out);

    out
}

/// Emits utility types that power the typed client API.
fn generate_type_helpers(out: &mut String) {
    let _ = writeln!(out, "type QueryKey = keyof Procedures[\"queries\"];");
    let _ = writeln!(out, "type MutationKey = keyof Procedures[\"mutations\"];");
    let _ = writeln!(out, "type QueryInput<K extends QueryKey> = Procedures[\"queries\"][K][\"input\"];");
    let _ = writeln!(out, "type QueryOutput<K extends QueryKey> = Procedures[\"queries\"][K][\"output\"];");
    let _ = writeln!(out, "type MutationInput<K extends MutationKey> = Procedures[\"mutations\"][K][\"input\"];");
    let _ = writeln!(out, "type MutationOutput<K extends MutationKey> = Procedures[\"mutations\"][K][\"output\"];");
}

/// Generates the `createRpcClient` factory using an interface for typed overloads.
fn generate_client_factory(manifest: &Manifest, preserve_docs: bool, out: &mut String) {
    let has_queries = manifest.procedures.iter().any(|p| p.kind == ProcedureKind::Query);
    let has_mutations = manifest.procedures.iter().any(|p| p.kind == ProcedureKind::Mutation);

    // Emit the RpcClient interface with overloaded method signatures
    let _ = writeln!(out, "export interface RpcClient {{");

    if has_queries {
        generate_query_overloads(manifest, preserve_docs, out);
    }

    if has_mutations {
        if has_queries {
            out.push('\n');
        }
        generate_mutation_overloads(manifest, preserve_docs, out);
    }

    let _ = writeln!(out, "}}");
    out.push('\n');

    // Emit the factory function
    let _ = writeln!(out, "export function createRpcClient(baseUrl: string): RpcClient {{");
    let _ = writeln!(out, "  return {{");

    if has_queries {
        let _ = writeln!(out, "    query(key: QueryKey, ...args: unknown[]): Promise<unknown> {{");
        let _ = writeln!(out, "      return rpcFetch(baseUrl, \"GET\", key, args[0]);");
        let _ = writeln!(out, "    }},");
    }

    if has_mutations {
        let _ = writeln!(out, "    mutate(key: MutationKey, ...args: unknown[]): Promise<unknown> {{");
        let _ = writeln!(out, "      return rpcFetch(baseUrl, \"POST\", key, args[0]);");
        let _ = writeln!(out, "    }},");
    }

    let _ = writeln!(out, "  }} as RpcClient;");
    let _ = writeln!(out, "}}");
}

/// Generates query overload signatures for the RpcClient interface.
fn generate_query_overloads(manifest: &Manifest, preserve_docs: bool, out: &mut String) {
    let queries: Vec<&Procedure> = manifest
        .procedures
        .iter()
        .filter(|p| p.kind == ProcedureKind::Query)
        .collect();

    let void_queries: Vec<&&Procedure> = queries.iter().filter(|p| is_void_input(p)).collect();
    let non_void_queries: Vec<&&Procedure> = queries.iter().filter(|p| !is_void_input(p)).collect();

    // Overload signatures for void-input queries (no input argument required)
    for proc in &void_queries {
        if preserve_docs {
            if let Some(doc) = &proc.docs {
                emit_jsdoc(doc, "  ", out);
            }
        }
        let output_ts = proc.output.as_ref().map(rust_type_to_ts).unwrap_or_else(|| "void".to_string());
        let _ = writeln!(
            out,
            "  query(key: \"{}\"): Promise<{}>;",
            proc.name, output_ts,
        );
    }

    // Overload signatures for non-void-input queries
    for proc in &non_void_queries {
        if preserve_docs {
            if let Some(doc) = &proc.docs {
                emit_jsdoc(doc, "  ", out);
            }
        }
        let input_ts = proc.input.as_ref().map(rust_type_to_ts).unwrap_or_else(|| "void".to_string());
        let output_ts = proc.output.as_ref().map(rust_type_to_ts).unwrap_or_else(|| "void".to_string());
        let _ = writeln!(
            out,
            "  query(key: \"{}\", input: {}): Promise<{}>;",
            proc.name, input_ts, output_ts,
        );
    }
}

/// Generates mutation overload signatures for the RpcClient interface.
fn generate_mutation_overloads(manifest: &Manifest, preserve_docs: bool, out: &mut String) {
    let mutations: Vec<&Procedure> = manifest
        .procedures
        .iter()
        .filter(|p| p.kind == ProcedureKind::Mutation)
        .collect();

    let void_mutations: Vec<&&Procedure> = mutations.iter().filter(|p| is_void_input(p)).collect();
    let non_void_mutations: Vec<&&Procedure> = mutations.iter().filter(|p| !is_void_input(p)).collect();

    // Overload signatures for void-input mutations
    for proc in &void_mutations {
        if preserve_docs {
            if let Some(doc) = &proc.docs {
                emit_jsdoc(doc, "  ", out);
            }
        }
        let output_ts = proc.output.as_ref().map(rust_type_to_ts).unwrap_or_else(|| "void".to_string());
        let _ = writeln!(
            out,
            "  mutate(key: \"{}\"): Promise<{}>;",
            proc.name, output_ts,
        );
    }

    // Overload signatures for non-void-input mutations
    for proc in &non_void_mutations {
        if preserve_docs {
            if let Some(doc) = &proc.docs {
                emit_jsdoc(doc, "  ", out);
            }
        }
        let input_ts = proc.input.as_ref().map(rust_type_to_ts).unwrap_or_else(|| "void".to_string());
        let output_ts = proc.output.as_ref().map(rust_type_to_ts).unwrap_or_else(|| "void".to_string());
        let _ = writeln!(
            out,
            "  mutate(key: \"{}\", input: {}): Promise<{}>;",
            proc.name, input_ts, output_ts,
        );
    }
}

/// Returns `true` if the procedure takes no input (void).
fn is_void_input(proc: &Procedure) -> bool {
    match &proc.input {
        None => true,
        Some(ty) => ty.name == "()",
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::model::*;
    use std::path::PathBuf;

    fn make_query(name: &str, input: Option<RustType>, output: Option<RustType>) -> Procedure {
        Procedure {
            name: name.to_string(),
            kind: ProcedureKind::Query,
            input,
            output,
            source_file: PathBuf::from("api/test.rs"),
            docs: None,
        }
    }

    fn make_mutation(name: &str, input: Option<RustType>, output: Option<RustType>) -> Procedure {
        Procedure {
            name: name.to_string(),
            kind: ProcedureKind::Mutation,
            input,
            output,
            source_file: PathBuf::from("api/test.rs"),
            docs: None,
        }
    }

    fn make_manifest(procedures: Vec<Procedure>) -> Manifest {
        Manifest {
            procedures,
            structs: vec![],
            enums: vec![],
        }
    }

    #[test]
    fn contains_generated_header() {
        let manifest = make_manifest(vec![]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.starts_with("// This file is auto-generated"));
    }

    #[test]
    fn imports_procedures_type() {
        let manifest = make_manifest(vec![]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("import type { Procedures } from \"./rpc-types\""));
    }

    #[test]
    fn reexports_procedures_type() {
        let manifest = make_manifest(vec![]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("export type { Procedures }"));
    }

    #[test]
    fn contains_rpc_error_class() {
        let manifest = make_manifest(vec![]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("export class RpcError extends Error"));
        assert!(output.contains("this.status = status"));
    }

    #[test]
    fn contains_fetch_helper() {
        let manifest = make_manifest(vec![]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("async function rpcFetch("));
        assert!(output.contains("encodeURIComponent(JSON.stringify(input))"));
    }

    #[test]
    fn generates_query_method() {
        let manifest = make_manifest(vec![
            make_query("hello", Some(RustType::simple("String")), Some(RustType::simple("String"))),
        ]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("query(key: \"hello\", input: string): Promise<string>"));
        assert!(output.contains("rpcFetch(baseUrl, \"GET\", key, args[0])"));
        assert!(output.contains("export interface RpcClient"));
    }

    #[test]
    fn generates_void_query_overload() {
        let manifest = make_manifest(vec![
            make_query("version", None, Some(RustType::simple("String"))),
        ]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("query(key: \"version\"): Promise<string>"));
    }

    #[test]
    fn generates_mutation_method() {
        let manifest = make_manifest(vec![
            make_mutation("create_item", Some(RustType::simple("CreateInput")), Some(RustType::simple("Item"))),
        ]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("mutate(key: \"create_item\", input: CreateInput): Promise<Item>"));
        assert!(output.contains("rpcFetch(baseUrl, \"POST\", key, args[0])"));
        assert!(output.contains("export interface RpcClient"));
    }

    #[test]
    fn generates_void_mutation_overload() {
        let manifest = make_manifest(vec![
            make_mutation("reset", None, Some(RustType::simple("bool"))),
        ]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("mutate(key: \"reset\"): Promise<boolean>"));
    }

    #[test]
    fn generates_create_rpc_client_factory() {
        let manifest = make_manifest(vec![
            make_query("hello", Some(RustType::simple("String")), Some(RustType::simple("String"))),
        ]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("export function createRpcClient(baseUrl: string)"));
    }

    #[test]
    fn generates_type_helpers() {
        let manifest = make_manifest(vec![
            make_query("hello", Some(RustType::simple("String")), Some(RustType::simple("String"))),
        ]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("type QueryKey = keyof Procedures[\"queries\"]"));
        assert!(output.contains("type QueryInput<K extends QueryKey>"));
        assert!(output.contains("type QueryOutput<K extends QueryKey>"));
    }

    #[test]
    fn mixed_queries_and_mutations() {
        let manifest = make_manifest(vec![
            make_query("get_user", Some(RustType::simple("String")), Some(RustType::simple("User"))),
            make_mutation("delete_user", Some(RustType::simple("String")), Some(RustType::simple("bool"))),
        ]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("query(key: \"get_user\", input: string): Promise<User>"));
        assert!(output.contains("mutate(key: \"delete_user\", input: string): Promise<boolean>"));
    }

    #[test]
    fn empty_manifest_no_methods() {
        let manifest = make_manifest(vec![]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("createRpcClient"));
        assert!(!output.contains("query("));
        assert!(!output.contains("mutate("));
    }

    #[test]
    fn complex_types_in_overloads() {
        let manifest = make_manifest(vec![
            make_query(
                "search",
                Some(RustType::simple("SearchQuery")),
                Some(RustType::with_generics("Vec", vec![RustType::simple("SearchResult")])),
            ),
        ]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("query(key: \"search\", input: SearchQuery): Promise<SearchResult[]>"));
    }

    #[test]
    fn uses_get_for_queries_post_for_mutations() {
        let manifest = make_manifest(vec![
            make_query("q", Some(RustType::simple("String")), Some(RustType::simple("String"))),
            make_mutation("m", Some(RustType::simple("String")), Some(RustType::simple("String"))),
        ]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("rpcFetch(baseUrl, \"GET\", key"));
        assert!(output.contains("rpcFetch(baseUrl, \"POST\", key"));
    }

    #[test]
    fn custom_types_import_path() {
        let output = generate_client_file(&make_manifest(vec![]), "$lib/rpc-types", false);
        assert!(output.contains("from \"$lib/rpc-types\""));
    }

    #[test]
    fn import_path_with_extension() {
        let output = generate_client_file(&make_manifest(vec![]), "./rpc-types.js", false);
        assert!(output.contains("from \"./rpc-types.js\""));
    }

    #[test]
    fn interface_based_overloads() {
        let manifest = make_manifest(vec![
            make_query("test", None, Some(RustType::simple("String"))),
        ]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("export interface RpcClient"));
        assert!(output.contains("query(key: \"test\"): Promise<string>"));
        assert!(output.contains("createRpcClient(baseUrl: string): RpcClient"));
        assert!(output.contains("as RpcClient"));
    }

    #[test]
    fn response_unwrapping() {
        let manifest = make_manifest(vec![]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("json?.result?.data ?? json"));
    }

    #[test]
    fn imports_referenced_structs() {
        let manifest = Manifest {
            procedures: vec![
                make_query("get_time", None, Some(RustType::simple("TimeResponse"))),
            ],
            structs: vec![StructDef {
                name: "TimeResponse".to_string(),
                fields: vec![("timestamp".to_string(), RustType::simple("u64"))],
                source_file: PathBuf::from("api/time.rs"),
                docs: None,
            }],
            enums: vec![],
        };
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("import type { Procedures, TimeResponse } from \"./rpc-types\""));
        assert!(output.contains("export type { Procedures, TimeResponse }"));
    }

    #[test]
    fn error_handling_in_fetch() {
        let manifest = make_manifest(vec![]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(output.contains("if (!res.ok)"));
        assert!(output.contains("throw new RpcError("));
    }

    #[test]
    fn test_jsdoc_on_overload() {
        let manifest = make_manifest(vec![
            Procedure {
                name: "hello".to_string(),
                kind: ProcedureKind::Query,
                input: Some(RustType::simple("String")),
                output: Some(RustType::simple("String")),
                source_file: PathBuf::from("api/hello.rs"),
                docs: Some("Say hello.".to_string()),
            },
            Procedure {
                name: "reset".to_string(),
                kind: ProcedureKind::Mutation,
                input: None,
                output: Some(RustType::simple("bool")),
                source_file: PathBuf::from("api/reset.rs"),
                docs: Some("Reset state.".to_string()),
            },
        ]);
        let output = generate_client_file(&manifest, "./rpc-types", true);
        assert!(output.contains("  /** Say hello. */\n  query(key: \"hello\", input: string): Promise<string>;"));
        assert!(output.contains("  /** Reset state. */\n  mutate(key: \"reset\"): Promise<boolean>;"));
    }

    #[test]
    fn test_no_jsdoc_on_overload_when_disabled() {
        let manifest = make_manifest(vec![Procedure {
            name: "hello".to_string(),
            kind: ProcedureKind::Query,
            input: Some(RustType::simple("String")),
            output: Some(RustType::simple("String")),
            source_file: PathBuf::from("api/hello.rs"),
            docs: Some("Say hello.".to_string()),
        }]);
        let output = generate_client_file(&manifest, "./rpc-types", false);
        assert!(!output.contains("/**"));
    }
}
