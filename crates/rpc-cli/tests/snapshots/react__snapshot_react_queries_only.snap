---
source: crates/rpc-cli/tests/react.rs
expression: output
---
// This file is auto-generated by vercel-rpc-cli. Do not edit manually.
// Re-run `rpc generate` or use `rpc watch` to regenerate.

import { useState, useEffect, useRef, useCallback } from "react";

import { type RpcClient, RpcError, type CallOptions } from "./rpc-client";

import type { Procedures } from "./rpc-types";

export { RpcError };
export type { RpcClient, CallOptions, Procedures };

type QueryKey = keyof Procedures["queries"];
type QueryInput<K extends QueryKey> = Procedures["queries"][K]["input"];
type QueryOutput<K extends QueryKey> = Procedures["queries"][K]["output"];

type VoidQueryKey = "version";
type NonVoidQueryKey = "get_user";

export interface QueryOptions<K extends QueryKey> {
  /** Whether to execute the query. @default true */
  enabled?: boolean;

  /** Auto-refetch interval in milliseconds. Set to 0 or omit to disable. */
  refetchInterval?: number;

  /** Initial data shown before the first fetch completes. */
  placeholderData?: QueryOutput<K>;

  /** Per-call options forwarded to client.query(). */
  callOptions?: CallOptions;

  /** Called when the query succeeds. */
  onSuccess?: (data: QueryOutput<K>) => void;

  /** Called when the query fails. */
  onError?: (error: RpcError) => void;

  /** Called when the query settles (success or failure). */
  onSettled?: () => void;
}

export interface QueryResult<K extends QueryKey> {
  /** The latest successfully resolved data, or placeholderData. */
  readonly data: QueryOutput<K> | undefined;

  /** The error from the most recent failed fetch, cleared on success. */
  readonly error: RpcError | undefined;

  /** True while a fetch is in-flight (including the initial fetch). */
  readonly isLoading: boolean;

  /** True after the first successful fetch. Stays true across refetches. */
  readonly isSuccess: boolean;

  /** True when error is set. */
  readonly isError: boolean;

  /** Manually trigger a refetch. */
  refetch: () => Promise<void>;
}

export function useQuery<K extends "version">(client: RpcClient, key: K, options?: QueryOptions<K>): QueryResult<K>;
export function useQuery<K extends "get_user">(client: RpcClient, key: K, input: QueryInput<K>, options?: QueryOptions<K>): QueryResult<K>;
export function useQuery<K extends QueryKey>(
  client: RpcClient,
  ...args: unknown[]
): QueryResult<K> {
  const key = args[0] as K;

  const input = typeof args[1] === "object" && args.length > 2
    ? args[1] as QueryInput<K>
    : undefined;
  const options = (typeof args[1] === "object" && args.length === 2
    ? args[1]
    : args[2]) as QueryOptions<K> | undefined;

  const [data, setData] = useState<QueryOutput<K> | undefined>(options?.placeholderData);
  const [error, setError] = useState<RpcError | undefined>();
  const [isLoading, setIsLoading] = useState(true);

  const optionsRef = useRef(options);
  optionsRef.current = options;

  const fetchData = useCallback(async () => {
    if (optionsRef.current?.enabled === false) return;
    setIsLoading(true);
    setError(undefined);
    try {
      const callArgs: unknown[] = [key];
      if (input !== undefined) callArgs.push(input);
      if (optionsRef.current?.callOptions) callArgs.push(optionsRef.current.callOptions);
      const result = await (client.query as Function)(...callArgs) as QueryOutput<K>;
      setData(result);
      optionsRef.current?.onSuccess?.(result);
    } catch (e) {
      const err = e as RpcError;
      setError(err);
      optionsRef.current?.onError?.(err);
    } finally {
      setIsLoading(false);
      optionsRef.current?.onSettled?.();
    }
  }, [client, key, JSON.stringify(input)]);

  useEffect(() => {
    if (options?.enabled === false) return;
    void fetchData();

    if (options?.refetchInterval) {
      const interval = setInterval(fetchData, options.refetchInterval);
      return () => clearInterval(interval);
    }
  }, [fetchData, options?.enabled, options?.refetchInterval]);

  return {
    data, error, isLoading,
    isSuccess: data !== undefined,
    isError: error !== undefined,
    refetch: fetchData,
  };
}
