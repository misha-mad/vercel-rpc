---
source: crates/rpc-cli/tests/vue.rs
expression: output
---
// This file is auto-generated by vercel-rpc-cli. Do not edit manually.
// Re-run `rpc generate` or use `rpc watch` to regenerate.

import { ref, watch, onScopeDispose, type Ref } from "vue";

import { type RpcClient, RpcError, type CallOptions } from "./rpc-client";

import type { Procedures } from "./rpc-types";

export { RpcError };
export type { RpcClient, CallOptions, Procedures };

type QueryKey = keyof Procedures["queries"];
type QueryInput<K extends QueryKey> = Procedures["queries"][K]["input"];
type QueryOutput<K extends QueryKey> = Procedures["queries"][K]["output"];

type VoidQueryKey = "version";
type NonVoidQueryKey = "get_user";

export interface QueryOptions<K extends QueryKey> {
  /**
   * Whether to execute the query. @default true
   *
   * Pass a getter `() => bool` for reactive updates â€” a plain `boolean` is
   * read once when `useQuery` is called and will not trigger re-fetches.
   */
  enabled?: boolean | (() => boolean);

  /** Auto-refetch interval in milliseconds. Set to 0 or omit to disable. */
  refetchInterval?: number;

  /** Initial data shown before the first fetch completes. */
  placeholderData?: QueryOutput<K>;

  /** Per-call options forwarded to client.query(). */
  callOptions?: CallOptions;

  /** Called when the query succeeds. */
  onSuccess?: (data: QueryOutput<K>) => void;

  /** Called when the query fails. */
  onError?: (error: RpcError) => void;

  /** Called when the query settles (success or failure). */
  onSettled?: () => void;
}

export interface QueryResult<K extends QueryKey> {
  /** The latest successfully resolved data, or placeholderData. */
  readonly data: Ref<QueryOutput<K> | undefined>;

  /** The error from the most recent failed fetch, cleared on success. */
  readonly error: Ref<RpcError | undefined>;

  /** True while a fetch is in-flight (including the initial fetch). */
  readonly isLoading: Ref<boolean>;

  /** True after the first successful fetch. Stays true across refetches. */
  readonly isSuccess: boolean;

  /** True when the most recent fetch failed. */
  readonly isError: boolean;

  /** Manually trigger a refetch. */
  refetch: () => Promise<void>;
}

export function useQuery<K extends "version">(client: RpcClient, key: K, options?: QueryOptions<K>): QueryResult<K>;
export function useQuery<K extends "get_user">(client: RpcClient, key: K, input: () => QueryInput<K>, options?: QueryOptions<K>): QueryResult<K>;
export function useQuery<K extends QueryKey>(
  client: RpcClient,
  ...args: unknown[]
): QueryResult<K> {
  const key = args[0] as K;

  const inputFn = typeof args[1] === "function"
    ? args[1] as () => QueryInput<K>
    : undefined;
  const options = (typeof args[1] === "object" ? args[1] : args[2]) as
    | QueryOptions<K>
    | undefined;

  const data = ref<QueryOutput<K> | undefined>(options?.placeholderData) as Ref<QueryOutput<K> | undefined>;
  const error = ref<RpcError | undefined>();
  const hasFetched = ref(false);
  const isLoading = ref(false);

  async function fetchData(input?: QueryInput<K>) {
    isLoading.value = true;
    error.value = undefined;
    try {
      const callArgs: unknown[] = [key];
      if (input !== undefined) callArgs.push(input);
      if (options?.callOptions) callArgs.push(options.callOptions);
      data.value = await (client.query as (...a: unknown[]) => Promise<unknown>)(
        ...callArgs
      ) as QueryOutput<K>;
      hasFetched.value = true;
      options?.onSuccess?.(data.value!);
    } catch (e) {
      error.value = e as RpcError;
      options?.onError?.(error.value);
    } finally {
      isLoading.value = false;
      options?.onSettled?.();
    }
  }

  let intervalId: ReturnType<typeof setInterval> | undefined;

  const stopWatch = watch(
    () => {
      const enabled = typeof options?.enabled === "function"
        ? options.enabled()
        : (options?.enabled ?? true);
      const input = inputFn?.();
      return { enabled, input };
    },
    ({ enabled, input }) => {
      if (intervalId) { clearInterval(intervalId); intervalId = undefined; }
      if (!enabled) return;

      void fetchData(input);

      if (options?.refetchInterval) {
        intervalId = setInterval(() => fetchData(inputFn?.()), options.refetchInterval);
      }
    },
    { immediate: true, deep: true },
  );

  onScopeDispose(() => {
    stopWatch();
    if (intervalId) clearInterval(intervalId);
  });

  return {
    data,
    error,
    isLoading,
    get isSuccess() { return hasFetched.value && error.value === undefined; },
    get isError() { return error.value !== undefined; },
    refetch: () => fetchData(inputFn?.()),
  };
}
