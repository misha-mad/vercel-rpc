---
source: crates/rpc-cli/tests/vue.rs
expression: output
---
// This file is auto-generated by vercel-rpc-cli. Do not edit manually.
// Re-run `rpc generate` or use `rpc watch` to regenerate.

import { ref, computed, watch, onScopeDispose, type Ref, type ComputedRef } from "vue";

import { type RpcClient, RpcError, type CallOptions } from "./rpc-client";

import type { Procedures, TimeResponse, CreateInput, Item } from "./rpc-types";

export { RpcError };
export type { RpcClient, CallOptions, Procedures, TimeResponse, CreateInput, Item };

type QueryKey = keyof Procedures["queries"];
type QueryInput<K extends QueryKey> = Procedures["queries"][K]["input"];
type QueryOutput<K extends QueryKey> = Procedures["queries"][K]["output"];
type MutationKey = keyof Procedures["mutations"];
type MutationInput<K extends MutationKey> = Procedures["mutations"][K]["input"];
type MutationOutput<K extends MutationKey> = Procedures["mutations"][K]["output"];

type VoidQueryKey = "time";
type NonVoidQueryKey = "hello";
type NonVoidMutationKey = "create_item";
type MutationArgs<K extends MutationKey> = [input: MutationInput<K>];

export interface QueryOptions<K extends QueryKey> {
  /**
   * Whether to execute the query. @default true
   *
   * Pass a getter `() => bool` for reactive updates â€” a plain `boolean` is
   * read once when `useQuery` is called and will not trigger re-fetches.
   */
  enabled?: boolean | (() => boolean);

  /** Auto-refetch interval in milliseconds. Set to 0 or omit to disable. */
  refetchInterval?: number;

  /** Initial data shown before the first fetch completes. */
  placeholderData?: QueryOutput<K>;

  /** Per-call options forwarded to client.query(). */
  callOptions?: CallOptions;

  /** Called when the query succeeds. */
  onSuccess?: (data: QueryOutput<K>) => void;

  /** Called when the query fails. */
  onError?: (error: RpcError) => void;

  /** Called when the query settles (success or failure). */
  onSettled?: () => void;
}

export interface QueryResult<K extends QueryKey> {
  /** The latest successfully resolved data, or placeholderData. */
  readonly data: Ref<QueryOutput<K> | undefined>;

  /** The error from the most recent failed fetch, cleared on next attempt. */
  readonly error: Ref<RpcError | undefined>;

  /** True while a fetch is in-flight (including the initial fetch). */
  readonly isLoading: Ref<boolean>;

  /** True after the first successful fetch. Stays true even if a later refetch fails. */
  readonly isSuccess: ComputedRef<boolean>;

  /** True when the most recent fetch failed. */
  readonly isError: ComputedRef<boolean>;

  /** Manually trigger a refetch. No-op when `enabled` is false. Resets the polling interval. */
  refetch: () => Promise<void>;
}

export interface MutationOptions<K extends MutationKey> {
  /** Per-call options forwarded to client.mutate(). */
  callOptions?: CallOptions;

  /** Called when the mutation succeeds. */
  onSuccess?: (data: MutationOutput<K>) => void;

  /** Called when the mutation fails. */
  onError?: (error: RpcError) => void;

  /** Called when the mutation settles (success or failure). */
  onSettled?: () => void;
}

export interface MutationResult<K extends MutationKey> {
  /** Execute the mutation. Rejects on error. */
  mutate: (...args: MutationArgs<K>) => Promise<void>;

  /** Execute the mutation and return the result. Rejects on error. */
  mutateAsync: (...args: MutationArgs<K>) => Promise<MutationOutput<K>>;

  /** The latest successfully resolved data. */
  readonly data: Ref<MutationOutput<K> | undefined>;

  /** The error from the most recent failed mutation, cleared on next attempt. */
  readonly error: Ref<RpcError | undefined>;

  /** True while a mutation is in-flight. */
  readonly isLoading: Ref<boolean>;

  /** True after the most recent mutation succeeded. */
  readonly isSuccess: ComputedRef<boolean>;

  /** True when the most recent mutation failed. */
  readonly isError: ComputedRef<boolean>;

  /** Reset state back to idle (clear data, error, status). */
  reset: () => void;
}

const QUERY_OPTIONS_KEYS: string[] = [
  "enabled", "refetchInterval", "placeholderData", "callOptions",
  "onSuccess", "onError", "onSettled",
];

function isQueryOptions(v: unknown): boolean {
  if (v == null || typeof v !== "object") return false;
  return Object.keys(v as object).every(k => QUERY_OPTIONS_KEYS.includes(k));
}

export function useQuery<K extends "time">(client: RpcClient, key: K, options?: QueryOptions<K> | (() => QueryOptions<K>)): QueryResult<K>;
export function useQuery<K extends "hello">(client: RpcClient, key: K, input: () => QueryInput<K>, options?: QueryOptions<K> | (() => QueryOptions<K>)): QueryResult<K>;
export function useQuery<K extends QueryKey>(
  client: RpcClient,
  ...args: unknown[]
): QueryResult<K> {
  const key = args[0] as K;

  let inputFn: (() => QueryInput<K>) | undefined;
  let optionsArg: QueryOptions<K> | (() => QueryOptions<K>) | undefined;

  if (typeof args[1] === "function" && args[2] !== undefined) {
    inputFn = args[1] as () => QueryInput<K>;
    optionsArg = args[2] as QueryOptions<K> | (() => QueryOptions<K>) | undefined;
  } else if (typeof args[1] === "function") {
    const probe = (args[1] as () => unknown)();
    if (probe != null && typeof probe === "object" && isQueryOptions(probe)) {
      optionsArg = args[1] as () => QueryOptions<K>;
    } else {
      inputFn = args[1] as () => QueryInput<K>;
    }
  } else if (typeof args[1] === "object") {
    optionsArg = args[1] as QueryOptions<K>;
  }

  function resolveOptions(): QueryOptions<K> | undefined {
    return typeof optionsArg === "function" ? optionsArg() : optionsArg;
  }

  function resolveEnabled(): boolean {
    const opts = resolveOptions();
    return typeof opts?.enabled === "function"
      ? opts.enabled()
      : (opts?.enabled ?? true);
  }

  const data = ref<QueryOutput<K> | undefined>(resolveOptions()?.placeholderData) as Ref<QueryOutput<K> | undefined>;
  const error = ref<RpcError | undefined>();
  const hasFetched = ref(false);
  const isLoading = ref(false);
  const isSuccess = computed(() => hasFetched.value);
  const isError = computed(() => error.value !== undefined);

  async function fetchData(input?: QueryInput<K>, signal?: AbortSignal) {
    const opts = resolveOptions();
    isLoading.value = true;
    error.value = undefined;
    try {
      const callArgs: unknown[] = [key];
      if (input !== undefined) callArgs.push(input);
      const mergedCallOptions = signal
        ? { ...opts?.callOptions, signal: opts?.callOptions?.signal
            ? AbortSignal.any([signal, opts.callOptions.signal])
            : signal }
        : opts?.callOptions;
      if (mergedCallOptions) callArgs.push(mergedCallOptions);
      const result = await (client.query as (...a: unknown[]) => Promise<unknown>)(
        ...callArgs
      ) as QueryOutput<K>;
      if (signal?.aborted) return;
      data.value = result;
      hasFetched.value = true;
      opts?.onSuccess?.(data.value!);
    } catch (e) {
      if (signal?.aborted) return;
      error.value = e as RpcError;
      opts?.onError?.(error.value);
    } finally {
      if (!signal?.aborted) {
        isLoading.value = false;
        opts?.onSettled?.();
      }
    }
  }

  let controller: AbortController | undefined;
  let intervalId: ReturnType<typeof setInterval> | undefined;

  function setupInterval() {
    if (intervalId) { clearInterval(intervalId); intervalId = undefined; }
    const ri = resolveOptions()?.refetchInterval;
    if (resolveEnabled() && ri) {
      intervalId = setInterval(() => {
        if (controller && !controller.signal.aborted) {
          void fetchData(inputFn?.(), controller.signal);
        }
      }, ri);
    }
  }

  const stopWatch = watch(
    () => {
      const enabled = resolveEnabled();
      const input = inputFn?.();
      return { enabled, input, serialized: JSON.stringify(input), refetchInterval: resolveOptions()?.refetchInterval };
    },
    (curr, prev) => {
      const inputChanged = !prev || curr.enabled !== prev.enabled || curr.serialized !== prev.serialized;

      if (inputChanged) {
        if (controller) { controller.abort(); controller = undefined; }
        if (curr.enabled) {
          controller = new AbortController();
          void fetchData(curr.input, controller.signal);
        } else {
          isLoading.value = false;
        }
      }

      setupInterval();
    },
    { immediate: true },
  );

  onScopeDispose(() => {
    stopWatch();
    if (controller) controller.abort();
    if (intervalId) clearInterval(intervalId);
  });

  return {
    data,
    error,
    isLoading,
    isSuccess,
    isError,
    refetch: () => {
      if (!resolveEnabled()) return Promise.resolve();
      if (controller) controller.abort();
      controller = new AbortController();
      const promise = fetchData(inputFn?.(), controller.signal);
      setupInterval();
      return promise;
    },
  };
}

export function useMutation<K extends MutationKey>(
  client: RpcClient,
  key: K,
  options?: MutationOptions<K>,
): MutationResult<K> {
  const data = ref<MutationOutput<K> | undefined>() as Ref<MutationOutput<K> | undefined>;
  const error = ref<RpcError | undefined>();
  const isLoading = ref(false);
  const hasSucceeded = ref(false);
  const isSuccess = computed(() => hasSucceeded.value && error.value === undefined);
  const isError = computed(() => error.value !== undefined);

  async function execute(...input: MutationArgs<K>): Promise<MutationOutput<K>> {
    isLoading.value = true;
    error.value = undefined;
    hasSucceeded.value = false;
    try {
      const callArgs: unknown[] = [key];
      if (input.length > 0) callArgs.push(input[0]);
      if (options?.callOptions) callArgs.push(options.callOptions);
      const result = await (client.mutate as (...a: unknown[]) => Promise<unknown>)(
        ...callArgs
      ) as MutationOutput<K>;
      data.value = result;
      hasSucceeded.value = true;
      options?.onSuccess?.(result);
      return result;
    } catch (e) {
      error.value = e as RpcError;
      options?.onError?.(error.value);
      throw e;
    } finally {
      isLoading.value = false;
      options?.onSettled?.();
    }
  }

  return {
    mutate: async (...args: MutationArgs<K>) => { await execute(...args); },
    mutateAsync: (...args: MutationArgs<K>) => execute(...args),
    data,
    error,
    isLoading,
    isSuccess,
    isError,
    reset: () => { data.value = undefined; error.value = undefined; isLoading.value = false; hasSucceeded.value = false; },
  };
}
