---
source: crates/rpc-cli/tests/client.rs
expression: output
---
// This file is auto-generated by vercel-rpc-cli. Do not edit manually.
// Re-run `rpc generate` or use `rpc watch` to regenerate.

import type { Procedures } from "./rpc-types";

export type { Procedures };

export class RpcError extends Error {
  readonly status: number;
  readonly data: unknown;

  constructor(status: number, message: string, data?: unknown) {
    super(message);
    this.name = "RpcError";
    this.status = status;
    this.data = data;
  }
}

export interface RequestContext {
  procedure: string;
  method: "GET" | "POST";
  url: string;
  headers: Record<string, string>;
  input?: unknown;
}

export interface ResponseContext {
  procedure: string;
  method: "GET" | "POST";
  url: string;
  response: Response;
  data: unknown;
  duration: number;
}

export interface ErrorContext {
  procedure: string;
  method: "GET" | "POST";
  url: string;
  error: unknown;
  attempt: number;
  willRetry: boolean;
}

export interface RetryPolicy {
  attempts: number;
  delay: number | ((attempt: number) => number);
  retryOn?: number[];
}

export interface RpcClientConfig {
  baseUrl: string;
  fetch?: typeof globalThis.fetch;
  headers?:
    | Record<string, string>
    | (() => Record<string, string> | Promise<Record<string, string>>);
  onRequest?: (ctx: RequestContext) => void | Promise<void>;
  onResponse?: (ctx: ResponseContext) => void | Promise<void>;
  onError?: (ctx: ErrorContext) => void | Promise<void>;
  retry?: RetryPolicy;
  timeout?: number;
  serialize?: (input: unknown) => string;
  deserialize?: (text: string) => unknown;
  // AbortSignal for cancelling all requests made by this client.
  signal?: AbortSignal;
}

const DEFAULT_RETRY_ON = [408, 429, 500, 502, 503, 504];

async function rpcFetch(
  config: RpcClientConfig,
  method: "GET" | "POST",
  procedure: string,
  input?: unknown,
): Promise<unknown> {
  let url = `${config.baseUrl}/${procedure}`;
  const customHeaders = typeof config.headers === "function"
    ? await config.headers()
    : config.headers;
  const baseHeaders: Record<string, string> = { ...customHeaders };

  if (method === "GET" && input !== undefined) {
    const serialized = config.serialize ? config.serialize(input) : JSON.stringify(input);
    url += `?input=${encodeURIComponent(serialized)}`;
  } else if (method === "POST" && input !== undefined) {
    baseHeaders["Content-Type"] = "application/json";
  }

  const fetchFn = config.fetch ?? globalThis.fetch;
  const maxAttempts = 1 + (config.retry?.attempts ?? 0);
  const retryOn = config.retry?.retryOn ?? DEFAULT_RETRY_ON;
  const start = Date.now();

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    const reqCtx: RequestContext = { procedure, method, url, headers: { ...baseHeaders }, input };
    await config.onRequest?.(reqCtx);

    const init: RequestInit = { method, headers: reqCtx.headers };
    if (method === "POST" && input !== undefined) {
      init.body = config.serialize ? config.serialize(input) : JSON.stringify(input);
    }

    let timeoutId: ReturnType<typeof setTimeout> | undefined;
    if (config.timeout) {
      const controller = new AbortController();
      timeoutId = setTimeout(() => controller.abort(), config.timeout);
      init.signal = config.signal
        ? AbortSignal.any([config.signal, controller.signal])
        : controller.signal;
    } else if (config.signal) {
      init.signal = config.signal;
    }

    try {
      const res = await fetchFn(url, init);

      if (!res.ok) {
        let data: unknown;
        try {
          data = await res.json();
        } catch {
          data = await res.text().catch(() => null);
        }
        const rpcError = new RpcError(
          res.status,
          `RPC error on "${procedure}": ${res.status} ${res.statusText}`,
          data,
        );
        const canRetry = retryOn.includes(res.status) && attempt < maxAttempts;
        await config.onError?.({ procedure, method, url, error: rpcError, attempt, willRetry: canRetry });
        if (!canRetry) throw rpcError;
      } else {
        const json = config.deserialize ? config.deserialize(await res.text()) : await res.json();
        const result = json?.result?.data ?? json;
        const duration = Date.now() - start;
        await config.onResponse?.({ procedure, method, url, response: res, data: result, duration });
        return result;
      }
    } catch (err) {
      if (err instanceof RpcError) throw err;
      const willRetry = attempt < maxAttempts;
      await config.onError?.({ procedure, method, url, error: err, attempt, willRetry });
      if (!willRetry) throw err;
    } finally {
      if (timeoutId !== undefined) clearTimeout(timeoutId);
    }

    if (config.retry) {
      const d = typeof config.retry.delay === "function"
        ? config.retry.delay(attempt) : config.retry.delay;
      await new Promise(r => setTimeout(r, d));
    }
  }
}

type QueryKey = keyof Procedures["queries"];
type MutationKey = keyof Procedures["mutations"];
type QueryInput<K extends QueryKey> = Procedures["queries"][K]["input"];
type QueryOutput<K extends QueryKey> = Procedures["queries"][K]["output"];
type MutationInput<K extends MutationKey> = Procedures["mutations"][K]["input"];
type MutationOutput<K extends MutationKey> = Procedures["mutations"][K]["output"];

export interface RpcClient {
}

export function createRpcClient(config: RpcClientConfig): RpcClient {
  return {
  } as RpcClient;
}
