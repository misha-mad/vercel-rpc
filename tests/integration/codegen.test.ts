import { describe, it, expect, beforeAll } from "vitest";
import { execSync } from "node:child_process";
import { readFileSync, existsSync, mkdirSync, writeFileSync, rmSync } from "node:fs";
import { join } from "node:path";

const ROOT = process.cwd();
const API_DIR = join(ROOT, "api");
const CLI_CMD = `cargo run -p vercel-rpc-cli --`;
const JSON_MARKER = "--- JSON manifest ---";

// Temporary output directory for test artifacts
const TEST_OUT = join(ROOT, "tests", "integration", ".tmp");

function runCli(args: string): string {
  return execSync(`${CLI_CMD} ${args}`, {
    cwd: ROOT,
    encoding: "utf-8",
    timeout: 60_000,
  });
}

describe("codegen pipeline: scan → generate → validate", () => {
  beforeAll(() => {
    if (existsSync(TEST_OUT)) rmSync(TEST_OUT, { recursive: true });
    mkdirSync(TEST_OUT, { recursive: true });
  });

  // --- Phase 1: Scan ---

  it("scans real api/ directory and discovers procedures", () => {
    const output = runCli(`scan --dir ${API_DIR}`);
    expect(output).toContain("procedure(s)");
    expect(output).toContain("hello");
    expect(output).toContain("time");
  });

  it("scan output contains valid JSON manifest", () => {
    const output = runCli(`scan --dir ${API_DIR}`);
    const markerIdx = output.indexOf(JSON_MARKER);
    const jsonBlock = output.slice(markerIdx + JSON_MARKER.length).trim();
    const manifest = JSON.parse(jsonBlock);

    expect(manifest).toHaveProperty("procedures");
    expect(manifest).toHaveProperty("structs");
    expect(Array.isArray(manifest.procedures)).toBe(true);
    expect(manifest.procedures.length).toBeGreaterThanOrEqual(2);
  });

  it("manifest procedures have correct structure", () => {
    const output = runCli(`scan --dir ${API_DIR}`);
    const markerIdx = output.indexOf(JSON_MARKER);
    const manifest = JSON.parse(output.slice(markerIdx + JSON_MARKER.length).trim());

    const hello = manifest.procedures.find((p: any) => p.name === "hello");
    expect(hello).toBeDefined();
    expect(hello.kind).toBe("query");
    expect(hello.input).toEqual({ name: "String", generics: [] });
    expect(hello.output).toEqual({ name: "String", generics: [] });

    const time = manifest.procedures.find((p: any) => p.name === "time");
    expect(time).toBeDefined();
    expect(time.kind).toBe("query");
    expect(time.input).toBeNull();
    expect(time.output).toEqual({ name: "TimeResponse", generics: [] });
  });

  it("manifest structs include TimeResponse with correct fields", () => {
    const output = runCli(`scan --dir ${API_DIR}`);
    const markerIdx = output.indexOf(JSON_MARKER);
    const manifest = JSON.parse(output.slice(markerIdx + JSON_MARKER.length).trim());

    const timeResp = manifest.structs.find((s: any) => s.name === "TimeResponse");
    expect(timeResp).toBeDefined();
    expect(timeResp.fields).toEqual(
      expect.arrayContaining([
        ["timestamp", { name: "u64", generics: [] }],
        ["message", { name: "String", generics: [] }],
      ]),
    );
  });

  // --- Phase 2: Generate types ---

  it("generates valid rpc-types.ts", () => {
    const typesPath = join(TEST_OUT, "rpc-types.ts");
    const clientPath = join(TEST_OUT, "rpc-client.ts");
    runCli(`generate --dir ${API_DIR} --output ${typesPath} --client-output ${clientPath}`);

    expect(existsSync(typesPath)).toBe(true);
    const content = readFileSync(typesPath, "utf-8");

    // Header
    expect(content).toContain("auto-generated by vercel-rpc-cli");

    // TimeResponse interface
    expect(content).toContain("export interface TimeResponse");
    expect(content).toContain("timestamp: number");
    expect(content).toContain("message: string");

    // Procedures type
    expect(content).toContain("export type Procedures");
    expect(content).toContain("queries:");
    expect(content).toContain('hello: { input: string; output: string }');
    expect(content).toContain('time: { input: void; output: TimeResponse }');
  });

  // --- Phase 3: Generate client ---

  it("generates valid rpc-client.ts", () => {
    const typesPath = join(TEST_OUT, "rpc-types.ts");
    const clientPath = join(TEST_OUT, "rpc-client.ts");
    runCli(`generate --dir ${API_DIR} --output ${typesPath} --client-output ${clientPath}`);

    expect(existsSync(clientPath)).toBe(true);
    const content = readFileSync(clientPath, "utf-8");

    // Header
    expect(content).toContain("auto-generated by vercel-rpc-cli");

    // Imports
    expect(content).toContain('import type { Procedures, TimeResponse }');

    // RpcError class
    expect(content).toContain("export class RpcError extends Error");

    // RpcClient interface with overloads
    expect(content).toContain("export interface RpcClient");
    expect(content).toContain('query(key: "hello", input: string): Promise<string>');
    expect(content).toContain('query(key: "time"): Promise<TimeResponse>');

    // Factory function
    expect(content).toContain("export function createRpcClient(baseUrl: string): RpcClient");
  });

  // --- Phase 4: TypeScript compilation ---

  it("generated files pass TypeScript type-checking", () => {
    const typesPath = join(TEST_OUT, "rpc-types.ts");
    const clientPath = join(TEST_OUT, "rpc-client.ts");
    runCli(`generate --dir ${API_DIR} --output ${typesPath} --client-output ${clientPath} --types-import ./rpc-types`);

    // Run tsc --noEmit on the generated files
    const result = execSync(`npx tsc --noEmit --strict --moduleResolution bundler --module esnext --target esnext ${clientPath}`, {
      cwd: ROOT,
      encoding: "utf-8",
      timeout: 30_000,
    });
    // tsc exits 0 on success — if it throws, the test fails
    expect(result).toBeDefined();
  });

  // --- Phase 5: Idempotency ---

  it("regeneration produces identical output", () => {
    const typesPath = join(TEST_OUT, "rpc-types.ts");
    const clientPath = join(TEST_OUT, "rpc-client.ts");

    runCli(`generate --dir ${API_DIR} --output ${typesPath} --client-output ${clientPath}`);
    const types1 = readFileSync(typesPath, "utf-8");
    const client1 = readFileSync(clientPath, "utf-8");

    runCli(`generate --dir ${API_DIR} --output ${typesPath} --client-output ${clientPath}`);
    const types2 = readFileSync(typesPath, "utf-8");
    const client2 = readFileSync(clientPath, "utf-8");

    expect(types1).toBe(types2);
    expect(client1).toBe(client2);
  });

  // --- Phase 6: Edge cases ---

  it("scan fails gracefully on empty directory", () => {
    const emptyDir = join(TEST_OUT, "empty-api");
    mkdirSync(emptyDir, { recursive: true });

    expect(() => runCli(`scan --dir ${emptyDir}`)).toThrow();
  });

  it("handles new procedure added to api/", () => {
    // Create a temporary api directory with an extra procedure
    const tmpApi = join(TEST_OUT, "extended-api");
    mkdirSync(tmpApi, { recursive: true });

    // Copy existing files
    for (const file of ["hello.rs", "time.rs"]) {
      const src = readFileSync(join(API_DIR, file), "utf-8");
      writeFileSync(join(tmpApi, file), src);
    }

    // Add a new procedure
    writeFileSync(
      join(tmpApi, "echo.rs"),
      `use vercel_rpc_macro::rpc_query;\n#[rpc_query]\nasync fn echo(msg: String) -> String { msg }\n`,
    );

    const typesPath = join(TEST_OUT, "extended-types.ts");
    const clientPath = join(TEST_OUT, "extended-client.ts");
    runCli(`generate --dir ${tmpApi} --output ${typesPath} --client-output ${clientPath}`);

    const types = readFileSync(typesPath, "utf-8");
    expect(types).toContain("echo: { input: string; output: string }");
    expect(types).toContain("hello: { input: string; output: string }");
    expect(types).toContain("time: { input: void; output: TimeResponse }");

    const client = readFileSync(clientPath, "utf-8");
    expect(client).toContain('query(key: "echo", input: string): Promise<string>');
  });
});

describe("codegen: production files match generated output", () => {
  it("src/lib/rpc-types.ts matches fresh generation", () => {
    const freshTypesPath = join(TEST_OUT, "fresh-types.ts");
    const freshClientPath = join(TEST_OUT, "fresh-client.ts");
    runCli(`generate --dir ${API_DIR} --output ${freshTypesPath} --client-output ${freshClientPath}`);

    const prodTypes = readFileSync(join(ROOT, "src/lib/rpc-types.ts"), "utf-8");
    const freshTypes = readFileSync(freshTypesPath, "utf-8");
    expect(prodTypes).toBe(freshTypes);
  });

  it("src/lib/rpc-client.ts matches fresh generation", () => {
    const freshTypesPath = join(TEST_OUT, "fresh-types.ts");
    const freshClientPath = join(TEST_OUT, "fresh-client.ts");
    runCli(`generate --dir ${API_DIR} --output ${freshTypesPath} --client-output ${freshClientPath}`);

    const prodClient = readFileSync(join(ROOT, "src/lib/rpc-client.ts"), "utf-8");
    const freshClient = readFileSync(freshClientPath, "utf-8");
    expect(prodClient).toBe(freshClient);
  });
});
